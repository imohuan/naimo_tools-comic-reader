<!DOCTYPE html>
<html lang="zh-CN" class="dark">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>JMComic å‰ç«¯é˜…è¯»å™¨</title>

  <!-- Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      darkMode: 'class',
      theme: {
        extend: {
          colors: {
            primary: '#ec4899', // JM ç²‰è‰²é£æ ¼
            darkbg: '#1a1a1a',
            cardbg: '#242424'
          }
        }
      }
    }
  </script>

  <!-- Vue 3 -->
  <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
  <!-- VueUse -->
  <script src="https://unpkg.com/@vueuse/shared"></script>
  <script src="https://unpkg.com/@vueuse/core"></script>
  <!-- Axios -->
  <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
  <!-- CryptoJS for MD5 and AES -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.2.0/crypto-js.min.js"></script>
  <!-- Naive UI -->
  <script src="https://unpkg.com/naive-ui@2.38.2/dist/index.js"></script>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap">

  <style>
    html,
    body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
      background-color: #121212;
      color: #e5e7eb;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }

    #app {
      height: 100vh;
      width: 100vw;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }

    #app>main {
      flex: 1;
      min-height: 0;
    }

    .n-split {
      height: 100% !important;
    }

    .n-split-pane {
      height: 100% !important;
      overflow: hidden;
    }

    /* æœç´¢æ¡†æ ·å¼ä¼˜åŒ– */
    .search-input {
      transition: all 0.2s ease;
      outline: none;
      box-shadow: none;
    }

    .search-input:focus-within {
      outline: none;
      box-shadow: none;
    }

    .search-btn {
      font-weight: 500;
      letter-spacing: 0.3px;
    }

    .search-btn:hover {
      transform: translateY(-1px);
    }

    .search-btn:active {
      transform: translateY(0);
    }

    /* å›¾ç‰‡å®¹å™¨æ ·å¼ - æ— é—´éš” */
    .image-preview-wrapper {
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      justify-content: flex-start;
      align-items: center;
      overflow: hidden;
      position: relative;
    }

    .image-scale-container {
      margin: 0 auto;
      width: 100%;
      flex: 1 1 auto;
      min-height: 0;
      display: flex;
      flex-direction: column;
    }

    .image-virtual-list {
      width: 100%;
      height: 100%;
      margin: 0;
      padding: 0;
      flex: 1 1 auto;
      min-height: 0;
    }

    /* ç¡®ä¿è™šæ‹Ÿåˆ—è¡¨å†…å®¹ä¸ä¼šäº§ç”Ÿé¢å¤–ç©ºç™½ */
    .image-virtual-list .n-virtual-list {
      height: 100% !important;
    }

    .image-item {
      width: 100%;
      margin: 0;
      padding: 0;
      display: block;
      line-height: 0;
    }

    .image-item>div {
      margin: 0;
      padding: 0;
      border-radius: 0;
    }

    .image-item img {
      display: block;
      width: 100%;
      height: auto;
      margin: 0;
      padding: 0;
    }
  </style>
</head>

<body class="w-full h-screen overflow-hidden select-none">
  <div id="app" class="h-full overflow-hidden">
    <n-config-provider :theme="darkTheme" class="h-full overflow-hidden">
      <n-message-provider placement="bottom-right">
        <n-notification-provider placement="bottom-right">
          <!-- ä¸»è¦å†…å®¹åŒºåŸŸ - å·¦å³å¸ƒå±€ -->
          <main class="h-full overflow-hidden">
            <n-split direction="horizontal" v-model:size="splitSize" :min="0" :max="1" class="h-full">
              <template #1>
                <!-- å·¦ä¾§ï¼šæ¼«ç”»åˆ—è¡¨ -->
                <div class="h-full flex flex-col bg-darkbg overflow-hidden border-r border-gray-800"
                  style="height: 100%;" ref="leftPanelRef">
                  <!-- æœç´¢å’Œè®¾ç½®æ  -->
                  <div class="p-4 border-b border-gray-800 flex items-center gap-3 flex-shrink-0">
                    <n-button circle quaternary @click="showSettings = true" size="medium">
                      <n-icon :size="20">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
                          <path
                            d="M19.14 12.94c.04-.3.06-.61.06-.94 0-.32-.02-.64-.07-.94l2.03-1.58c.18-.14.23-.41.12-.61l-1.92-3.32c-.12-.22-.37-.29-.59-.22l-2.39.96c-.5-.38-1.03-.7-1.62-.94l-.36-2.54c-.04-.24-.24-.41-.48-.41h-3.84c-.24 0-.43.17-.47.41l-.36 2.54c-.59.24-1.13.57-1.62.94l-2.39-.96c-.22-.08-.47 0-.59.22L2.74 8.87c-.12.21-.08.47.12.61l2.03 1.58c-.05.3-.07.62-.07.94s.02.64.07.94l-2.03 1.58c-.18.14-.23.41-.12.61l1.92 3.32c.12.22.37.29.59.22l2.39-.96c.5.38 1.03.7 1.62.94l.36 2.54c.05.24.24.41.48.41h3.84c.24 0 .44-.17.47-.41l.36-2.54c.59-.24 1.13-.56 1.62-.94l2.39.96c.22.08.47 0 .59-.22l1.92-3.32c.12-.22.07-.47-.12-.61l-2.01-1.58zM12 15.6c-1.98 0-3.6-1.62-3.6-3.6s1.62-3.6 3.6-3.6 3.6 1.62 3.6 3.6-1.62 3.6-3.6 3.6z" />
                        </svg>
                      </n-icon>
                    </n-button>
                    <div class="flex-1 relative group">
                      <n-input v-model:value="searchQuery" placeholder="è¾“å…¥è½¦å·(ID) æˆ– å…³é”®è¯" clearable
                        @keyup.enter="() => handleSearch(1, false)" :theme-overrides="{
                    color: '#1f1f1f',
                    colorHover: '#2a2a2a',
                    colorFocus: '#1f1f1f',
                    borderColor: '#3a3a3a',
                    borderColorHover: '#4a4a4a',
                    borderColorFocus: '#ec4899',
                    textColor: '#e5e7eb',
                    placeholderColor: '#6b7280',
                    borderRadius: '6px',
                    heightMedium: '40px'
                  }" size="medium" class="search-input">
                        <template #prefix>
                          <n-icon :size="18" class="text-gray-500 group-hover:text-gray-400 transition-colors">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
                              stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                              <circle cx="11" cy="11" r="8"></circle>
                              <path d="m21 21-4.35-4.35"></path>
                            </svg>
                          </n-icon>
                        </template>
                      </n-input>
                    </div>
                    <n-button @click="() => handleSearch(1, false)" size="medium" color="#ec4899"
                      class="search-btn transition-all duration-200 text-white">
                      æœç´¢
                    </n-button>
                    <n-button circle quaternary @click="toggleRightPanel" size="medium"
                      :title="splitSize === 1 ? 'å±•å¼€å³ä¾§é¢æ¿' : 'æŠ˜å å³ä¾§é¢æ¿'">
                      <n-icon :size="20">
                        <svg v-if="splitSize === 1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
                          stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                          <polyline points="9 18 15 12 9 6"></polyline>
                        </svg>
                        <svg v-else xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
                          stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                          <polyline points="15 18 9 12 15 6"></polyline>
                        </svg>
                      </n-icon>
                    </n-button>

                  </div>

                  <div class="flex-1 overflow-hidden" style="height: 100%; display: flex; flex-direction: column;">
                    <div v-if="loading && comicList.length === 0" class="py-20 text-center text-gray-500">
                      <n-spin size="large">
                        <template #description>
                          <p>æ­£åœ¨åŠ è½½æ•°æ®...</p>
                        </template>
                      </n-spin>
                    </div>

                    <div v-else-if="comicList.length === 0" class="text-center py-20 text-gray-500">
                      <n-empty description="æš‚æ— æ•°æ®ï¼Œè¯·å°è¯•æœç´¢" />
                    </div>

                    <n-infinite-scroll v-else :distance="10" @load="handleLoad" class="w-full h-full"
                      id="image-scroll-container">
                      <div class="p-2"
                        :style="{ display: 'grid', gridTemplateColumns: `repeat(${leftColumnCount}, minmax(150px, 250px))`, gap: '0.5rem' }">
                        <div v-for="item in comicList" :key="item.id"
                          class="bg-cardbg rounded-lg overflow-hidden hover:ring-2 ring-primary transition cursor-pointer group"
                          :class="{ 'ring-2 ring-primary': currentComic.id === item.id }" @click="viewDetail(item)">
                          <div class="aspect-[2/3] overflow-hidden relative">
                            <n-image :src="getProxiedUrl(item.cover || '', true)" lazy preview-disabled
                              class="w-full h-full object-cover group-hover:scale-105 transition duration-300"
                              :intersection-observer-options="{
                                root: '#image-scroll-container',
                              }" @error="handleImgError">
                              <template #placeholder>
                                <div class="flex items-center justify-center w-full h-full bg-gray-800">
                                  <n-spin size="small" />
                                </div>
                              </template>
                            </n-image>
                            <div
                              class="absolute bottom-0 left-0 right-0 bg-gradient-to-t from-black/90 to-transparent p-2">
                              <span class="text-xs text-gray-300">{{ item.author }}</span>
                            </div>
                          </div>
                          <div class="p-2 flex flex-col gap-2">
                            <h3 class="text-xs font-bold line-clamp-2 h-8 text-gray-100">{{ item.title }}</h3>
                            <div class="flex justify-between items-center mt-1">
                              <n-tag size="tiny" type="info">{{ item.id }}</n-tag>
                              <span class="text-xs text-gray-500">{{ item.date || 'æœ€æ–°' }}</span>
                            </div>
                          </div>
                        </div>
                      </div>
                      <!-- åŠ è½½çŠ¶æ€æç¤ºï¼ˆå‚è€ƒå®˜æ–¹ç¤ºä¾‹ï¼‰ -->
                      <div v-if="loading && comicList.length > 0" class="py-4 text-center text-gray-500">
                        <n-spin size="small" />
                        <p class="text-xs mt-2">åŠ è½½ä¸­...</p>
                      </div>
                      <!-- æ²¡æœ‰æ›´å¤šæç¤ºï¼ˆå‚è€ƒå®˜æ–¹ç¤ºä¾‹ï¼‰ -->
                      <div v-if="!hasMorePages && comicList.length > 0 && !loading"
                        class="py-4 text-center text-gray-500">
                        <p class="text-xs">æ²¡æœ‰æ›´å¤šäº† ğŸ¤ª</p>
                      </div>
                    </n-infinite-scroll>
                  </div>

                  <!-- åˆ†é¡µç»„ä»¶ -->
                  <div class="p-4 border-t border-gray-800 flex items-center gap-4 flex-shrink-0">
                    <div class="flex-1 min-w-0">
                      <n-pagination v-model:page="currentPage" :page-size="pageSize" :item-count="totalItems"
                        @update:page="handlePageChange" :disabled="loading" size="small" />
                    </div>
                    <div class="flex items-center gap-2 flex-shrink-0">
                      <n-button :type="autoLoadNextPage ? 'primary' : 'default'" size="small" round
                        @click="autoLoadNextPage = !autoLoadNextPage" :theme-overrides="{
                      colorPrimary: '#ec4899',
                      colorPrimaryHover: '#db2777',
                      colorPrimaryPressed: '#be185d',
                      borderRadius: '8px',
                      heightSmall: '32px',
                      paddingSmall: '0 16px'
                    }" class="transition-all">
                        <template #icon>
                          <n-icon :size="16">
                            <svg v-if="autoLoadNextPage" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"
                              fill="currentColor">
                              <path
                                d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z" />
                            </svg>
                            <svg v-else xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
                              stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                              <polyline points="6 9 12 15 18 9"></polyline>
                            </svg>
                          </n-icon>
                        </template>
                        {{ autoLoadNextPage ? 'è‡ªåŠ¨åŠ è½½' : 'æ‰‹åŠ¨ç¿»é¡µ' }}
                      </n-button>
                    </div>
                  </div>
                </div>
              </template>
              <template #2>
                <!-- å³ä¾§ï¼šè¯¦æƒ…/å›¾ç‰‡é¢„è§ˆ -->
                <div class="h-full flex flex-col overflow-hidden bg-darkbg" style="height: 100%;">
                  <div v-if="!currentComic.id" class="flex-1 flex items-center justify-center text-gray-500">
                    <n-empty description="è¯·ä»å·¦ä¾§é€‰æ‹©æ¼«ç”»" />
                  </div>

                  <div v-else class="flex-1 flex flex-col overflow-hidden">
                    <!-- Tab åˆ‡æ¢å’Œå·¥å…·æ  -->
                    <div class="border-b border-gray-800 flex items-center justify-between relative">
                      <!-- å·¦ä¾§ï¼šTab åˆ‡æ¢ï¼Œå æ®å‰©ä½™ç©ºé—´ -->
                      <div class="flex-1 min-w-0 pl-4">
                        <n-tabs v-model:value="rightTab" type="line" animated>
                          <n-tab name="detail">è¯¦æƒ…</n-tab>
                          <n-tab name="images" :disabled="!currentChapter.id">å›¾ç‰‡é¢„è§ˆ</n-tab>
                        </n-tabs>
                      </div>

                      <div>
                        <!-- é˜…è¯»è¿›åº¦ï¼ˆä»…åœ¨å›¾ç‰‡é¢„è§ˆæ—¶æ˜¾ç¤ºï¼‰ -->
                        <div v-if="rightTab === 'images' && readingImages.length > 0"
                          class="flex items-center gap-2 max-w-xs absolute left-1/2 top-0 bottom-0  -translate-x-1/2">
                          <span class="text-xs text-gray-300 whitespace-nowrap">é˜…è¯»è¿›åº¦ï¼š</span>
                          <span class="text-sm font-bold text-white">{{ currentImageIndex + 1 }}</span>
                          <span class="text-xs text-gray-400">/</span>
                          <span class="text-xs text-gray-400">{{ readingImages.length }}</span>
                        </div>
                      </div>

                      <!-- å³ä¾§ï¼šç« èŠ‚å¯¼èˆª + é˜…è¯»è¿›åº¦ + ç¼©æ”¾ + æŠ˜å æŒ‰é’® -->
                      <div class="flex items-center gap-3 px-2 py-2 flex-shrink-0 ">
                        <!-- ç« èŠ‚å¯¼èˆªï¼ˆä»…åœ¨å›¾ç‰‡é¢„è§ˆæ—¶æ˜¾ç¤ºï¼‰ -->
                        <!-- <div v-if="rightTab === 'images'" class="flex items-center gap-1">
                          <n-button :disabled="!hasPrevChapter" quaternary circle size="small" @click="goToPrevChapter">
                            <n-icon :size="16">
                              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
                                stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <polyline points="15 18 9 12 15 6"></polyline>
                              </svg>
                            </n-icon>
                          </n-button>
                          <span v-if="currentChapter.title" class="text-sm text-gray-300 px-1 min-w-[3rem] text-center">
                            {{ currentChapter.order || currentChapter.title?.match(/\d+/)?.[0] || 1 }}
                          </span>
                          <n-button :disabled="!hasNextChapter" quaternary circle size="small" @click="goToNextChapter">
                            <n-icon :size="16">
                              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
                                stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <polyline points="9 18 15 12 9 6"></polyline>
                              </svg>
                            </n-icon>
                          </n-button>
                        </div> -->



                        <!-- ç¼©æ”¾æ§åˆ¶ï¼ˆä»…åœ¨å›¾ç‰‡é¢„è§ˆæ—¶æ˜¾ç¤ºï¼‰ -->
                        <div v-if="rightTab === 'images'" class="flex items-center gap-2" style="min-width: 150px;">
                          <n-slider v-model:value="imageScale" :min="20" :max="100" :step="10" style="width: 160px;" />
                          <span class="text-xs text-gray-400" style="min-width: 40px;">{{ imageScale }}%</span>
                        </div>

                        <!-- æŠ˜å å·¦ä¾§é¢æ¿æŒ‰é’® -->
                        <n-button circle quaternary @click="toggleLeftPanel" size="small"
                          :title="splitSize === 0 ? 'å±•å¼€å·¦ä¾§é¢æ¿' : 'æŠ˜å å·¦ä¾§é¢æ¿'">
                          <n-icon :size="18">
                            <svg v-if="splitSize === 0" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"
                              fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                              stroke-linejoin="round">
                              <polyline points="9 18 15 12 9 6"></polyline>
                            </svg>
                            <svg v-else xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
                              stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                              <polyline points="15 18 9 12 15 6"></polyline>
                            </svg>
                          </n-icon>
                        </n-button>
                      </div>
                    </div>

                    <!-- Tab å†…å®¹ -->
                    <n-scrollbar style="height: 100%; flex: 1;">
                      <div class="p-6">
                        <!-- è¯¦æƒ… Tab -->
                        <div v-if="rightTab === 'detail'" class="max-w-4xl mx-auto">
                          <div class="bg-cardbg rounded-xl p-6 shadow-lg flex flex-col md:flex-row gap-6">
                            <!-- å°é¢ -->
                            <div class="w-full md:w-1/2 lg:w-1/3 flex-shrink-0">
                              <n-image :src="getProxiedUrl(currentComic.cover || '', true)" lazy
                                :preview-disabled="false" class="w-full rounded-lg shadow-md object-cover aspect-[2/3]"
                                @error="handleImgError">
                                <template #placeholder>
                                  <div class="flex items-center justify-center w-full h-full bg-gray-800">
                                    <n-spin size="small" />
                                  </div>
                                </template>
                              </n-image>
                            </div>

                            <!-- ä¿¡æ¯ -->
                            <div class="flex-1">
                              <h1 class="text-2xl md:text-3xl font-bold text-white mb-2">{{ currentComic.title }}</h1>
                              <p class="text-gray-400 text-sm mb-4">JM ID: {{ currentComic.id }}</p>

                              <div class="flex flex-wrap gap-2 mb-4">
                                <n-tag v-for="tag in currentComic.tags" :key="tag" type="default" round>{{ tag
                                  }}</n-tag>
                              </div>

                              <p class="text-gray-300 text-sm leading-relaxed mb-6">
                                {{ currentComic.description || 'æš‚æ— ç®€ä»‹...' }}
                              </p>

                              <div class="border-t border-gray-700 pt-4">
                                <h3 class="text-lg font-semibold mb-3 flex items-center">
                                  ç« èŠ‚åˆ—è¡¨
                                </h3>
                                <div v-if="detailLoading && chapterList.length === 0" class="py-10 text-center">
                                  <n-spin size="large" />
                                </div>
                                <div v-else class="grid grid-cols-2 sm:grid-cols-3 gap-3">
                                  <button v-for="chapter in chapterList" :key="chapter.id"
                                    class="px-4 py-3 bg-gray-700 hover:bg-primary rounded text-sm text-left transition truncate"
                                    :class="{ 'bg-primary': currentChapter.id === chapter.id }"
                                    @click="selectChapter(chapter)">
                                    {{ chapter.title }}
                                  </button>
                                </div>
                              </div>
                            </div>
                          </div>
                        </div>

                        <!-- å›¾ç‰‡é¢„è§ˆ Tab -->
                        <div v-else-if="rightTab === 'images'" class="w-full">
                          <div v-if="!currentChapter.id" class="text-center py-20 text-gray-500">
                            <n-empty description="è¯·å…ˆé€‰æ‹©ä¸€ä¸ªç« èŠ‚" />
                          </div>
                          <div v-else class="w-full">
                            <div class="text-center mb-4">
                              <h2 class="text-lg font-bold">{{ currentChapter.title }}</h2>
                              <p class="text-xs text-gray-500">å¦‚æœå›¾ç‰‡æ— æ³•åŠ è½½ï¼Œè¯·æ£€æŸ¥ä»£ç†è®¾ç½®</p>
                            </div>

                            <div v-if="detailLoading && readingImages.length === 0" class="py-40 text-center">
                              <n-spin size="large">
                                <template #description>
                                  <p class="mt-4">æ­£åœ¨è§£æå›¾ç‰‡...</p>
                                </template>
                              </n-spin>
                            </div>

                            <div v-else class="image-preview-wrapper">
                              <div class="image-scale-container"
                                :style="{ transform: `scale(${imageScale / 100})`, transformOrigin: 'top center', width: `${100 / (imageScale / 100)}%` }">
                                <n-virtual-list ref="imageListRef" :items="readingImages"
                                  :item-size="estimatedImageHeight" item-resizable
                                  :scrollbar-props="{ trigger: 'none' }" class="image-virtual-list"
                                  :on-scroll="handleImageListScroll">
                                  <template #default="{ item }">
                                    <div class="image-item" :data-index="item.index"
                                      @click="() => currentImageIndex = item.index">
                                      <div class="relative bg-gray-800 overflow-hidden">
                                        <n-image :src="getProxiedUrl(item.url, true)" preview-disabled
                                          :initial-index="item.index" object-fit="contain" lazy class="w-full block"
                                          style="display: block;" @load="handleImageLoad" @error="handleImageError">
                                          <template #placeholder>
                                            <div class="flex items-center justify-center h-[300px] text-gray-600">
                                              <n-spin size="small" />
                                              <span class="ml-2">åŠ è½½ä¸­ {{ item.index + 1 }}</span>
                                            </div>
                                          </template>
                                          <template #error>
                                            <div
                                              class="flex flex-col items-center justify-center h-[300px] text-red-400 bg-gray-900">
                                              <n-icon :size="30"><svg xmlns="http://www.w3.org/2000/svg"
                                                  viewBox="0 0 24 24" fill="currentColor">
                                                  <path
                                                    d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z" />
                                                </svg></n-icon>
                                              <span class="text-sm mt-2">åŠ è½½å¤±è´¥</span>
                                              <span class="text-xs text-gray-500 mt-1">è¯·æ£€æŸ¥ç½‘ç»œè¿æ¥æˆ–ä»£ç†è®¾ç½®</span>
                                            </div>
                                          </template>
                                        </n-image>
                                        <span
                                          class="absolute top-2 right-2 bg-black/50 px-2 py-1 rounded text-xs text-white pointer-events-none">
                                          {{ item.index + 1 }} / {{ readingImages.length }}
                                        </span>
                                      </div>
                                    </div>
                                  </template>
                                </n-virtual-list>
                              </div>
                            </div>
                          </div>
                        </div>
                    </n-scrollbar>
                  </div>
                </div>
              </template>
            </n-split>
          </main>

          <!-- è®¾ç½®å¼¹çª— -->
          <n-modal v-model:show="showSettings" preset="card" title="è®¾ç½®" style="width: 90%; max-width: 600px;">
            <n-scrollbar style="max-height: 70vh;">
              <div class="flex flex-col gap-4 pr-4">
                <n-alert type="warning" :closable="false" show-icon>
                  JMComic æœ‰ä¸¥æ ¼çš„é˜²ç›—é“¾ä¿æŠ¤ã€‚è¦ä½¿ç”¨æ­¤é¡µé¢ï¼Œæ‚¨å¿…é¡»æä¾›ä¸€ä¸ªèƒ½è½¬å‘è¯·æ±‚å¹¶ä¿®æ”¹ Headers çš„åç«¯ä»£ç†åœ°å€ã€‚
                </n-alert>

                <n-divider>ä»£ç†è®¾ç½®</n-divider>
                <div>
                  <label class="block text-sm font-medium mb-1">ä»£ç†æœåŠ¡ URL (CORS Proxy)</label>
                  <n-select v-model:value="settings.proxyUrl" :options="proxyUrlOptions" filterable tag clearable
                    placeholder="ä¾‹å¦‚: http://localhost:3000/proxy?url=" />
                  <p class="text-xs text-gray-500 mt-1">
                    ä»£ç†éœ€è¦å¤„ç†è¯·æ±‚å¹¶å°†å›¾ç‰‡æ•°æ®ä»¥äºŒè¿›åˆ¶æµè¿”å›ï¼ŒåŒæ—¶è®¾ç½® Header: `Referer: https://jmcomic.me/`
                  </p>
                </div>

                <n-divider>API é…ç½®</n-divider>
                <div>
                  <label class="block text-sm font-medium mb-1">API åŸŸå (API_DOMAIN)</label>
                  <n-select v-model:value="settings.apiDomain" :options="apiDomainOptions" filterable tag clearable
                    placeholder="ä¾‹å¦‚: www.cdnblackmyth.club" />
                </div>

                <div>
                  <label class="block text-sm font-medium mb-1">å›¾ç‰‡åŸŸå (IMAGE_DOMAIN)</label>
                  <n-select v-model:value="settings.imageDomain" :options="imageDomainOptions" filterable tag clearable
                    placeholder="ä¾‹å¦‚: cdn-msp2.jmapiproxy2.cc" />
                </div>

                <div>
                  <label class="block text-sm font-medium mb-1">Token å¯†é’¥ (APP_TOKEN_SECRET)</label>
                  <n-select v-model:value="settings.appTokenSecret" :options="tokenSecretOptions" filterable tag
                    clearable placeholder="ä¾‹å¦‚: 18comicAPP" />
                </div>

                <div>
                  <label class="block text-sm font-medium mb-1">Token å¯†é’¥ 2 (APP_TOKEN_SECRET_2)</label>
                  <n-select v-model:value="settings.appTokenSecret2" :options="tokenSecret2Options" filterable tag
                    clearable placeholder="ä¾‹å¦‚: 18comicAPPContent" />
                </div>

                <div>
                  <label class="block text-sm font-medium mb-1">æ•°æ®å¯†é’¥ (APP_DATA_SECRET)</label>
                  <n-select v-model:value="settings.appDataSecret" :options="dataSecretOptions" filterable tag clearable
                    placeholder="ä¾‹å¦‚: 185Hcomic3PAPP7R" />
                </div>

                <div>
                  <label class="block text-sm font-medium mb-1">åº”ç”¨ç‰ˆæœ¬ (APP_VERSION)</label>
                  <n-select v-model:value="settings.appVersion" :options="appVersionOptions" filterable tag clearable
                    placeholder="ä¾‹å¦‚: 1.7.5" />
                </div>

                <n-divider>ç¼“å­˜ç®¡ç†</n-divider>
                <div>
                  <p class="text-sm text-gray-400 mb-3">
                    ç¼“å­˜ç”¨äºæå‡åŠ è½½é€Ÿåº¦ï¼Œè‡ªåŠ¨åœ¨24å°æ—¶åè¿‡æœŸã€‚æ‚¨å¯ä»¥æ‰‹åŠ¨æ¸…é™¤ç¼“å­˜ä»¥è·å–æœ€æ–°æ•°æ®ã€‚
                  </p>
                  <div class="flex gap-2">
                    <n-button @click="clearCache('details')" size="small">æ¸…é™¤è¯¦æƒ…ç¼“å­˜</n-button>
                    <n-button @click="clearCache('chapters')" size="small">æ¸…é™¤å›¾ç‰‡ç¼“å­˜</n-button>
                    <n-button @click="clearCache()" size="small" type="error">æ¸…é™¤æ‰€æœ‰ç¼“å­˜</n-button>
                  </div>
                  <p class="text-xs text-gray-500 mt-2">
                    å½“å‰ç¼“å­˜ï¼šè¯¦æƒ… {{ getCacheCount('details') }} é¡¹ï¼Œå›¾ç‰‡ {{ getCacheCount('chapters') }} é¡¹
                  </p>
                </div>
              </div>
            </n-scrollbar>
            <template #footer>
              <div class="flex justify-between items-center">
                <n-button @click="resetSettings">é‡ç½®ä¸ºé»˜è®¤</n-button>
                <div class="flex gap-2">
                  <n-button @click="showSettings = false">å…³é—­</n-button>
                  <n-button type="primary" @click="saveSettings">ä¿å­˜</n-button>
                </div>
              </div>
            </template>
          </n-modal>
        </n-notification-provider>
      </n-message-provider>
    </n-config-provider>
  </div>

  <script>
    const { createApp, ref, reactive, onMounted, onUnmounted, watch, computed, nextTick } = Vue;
    const { useStorage } = VueUse;

    // ==================== ComicAPI ç±» ====================
    class ComicAPI {
      constructor(settings = {}) {
        // API é…ç½® - ä»è®¾ç½®ä¸­è¯»å–æˆ–ä½¿ç”¨é»˜è®¤å€¼
        this.updateSettings(settings);
      }

      // æ›´æ–°é…ç½®
      updateSettings(settings) {
        this.API_DOMAIN = settings.apiDomain || 'www.cdnblackmyth.club';
        this.IMAGE_DOMAIN = settings.imageDomain || 'cdn-msp2.jmapiproxy2.cc';
        this.APP_TOKEN_SECRET = settings.appTokenSecret || '18comicAPP';
        this.APP_TOKEN_SECRET_2 = settings.appTokenSecret2 || '18comicAPPContent';
        this.APP_DATA_SECRET = settings.appDataSecret || '185Hcomic3PAPP7R';
        this.APP_VERSION = settings.appVersion || '1.7.5';
      }

      // MD5 åŠ å¯†
      md5(str) {
        return CryptoJS.MD5(str).toString();
      }

      // ç”Ÿæˆ Token
      generateToken(timestamp, isScrambleId = false) {
        const secret = isScrambleId ? this.APP_TOKEN_SECRET_2 : this.APP_TOKEN_SECRET;
        return this.md5(timestamp + secret);
      }

      // è§£å¯†æ•°æ®
      decryptData(timestamp, encryptedData) {
        try {
          const keyHash = this.md5(timestamp + this.APP_DATA_SECRET);
          const key = keyHash.substring(0, 32);
          const keyBytes = CryptoJS.enc.Utf8.parse(key);

          const encrypted = CryptoJS.enc.Base64.parse(encryptedData);

          const decrypted = CryptoJS.AES.decrypt(
            { ciphertext: encrypted },
            keyBytes,
            {
              mode: CryptoJS.mode.ECB,
              padding: CryptoJS.pad.Pkcs7
            }
          );

          return decrypted.toString(CryptoJS.enc.Utf8);
        } catch (error) {
          throw new Error('è§£å¯†å¤±è´¥: ' + error.message);
        }
      }

      // è®¡ç®— block_numï¼ˆç”¨äºå›¾ç‰‡æ‹¼æ¥ï¼‰
      calculateBlockNum(scrambleId, chapterId, filename) {
        if (chapterId < scrambleId) {
          return 0;
        } else if (chapterId < 268850) {
          return 10;
        } else {
          const x = chapterId < 421926 ? 10 : 8;
          const s = `${chapterId}${filename}`;
          const hash = this.md5(s);
          let blockNum = hash.charCodeAt(hash.length - 1);
          blockNum %= x;
          blockNum = blockNum * 2 + 2;
          return blockNum;
        }
      }

      // æ‹¼æ¥å›¾ç‰‡ï¼ˆä½¿ç”¨ Canvas APIï¼‰
      async stitchImage(imageUrl, blockNum) {
        return new Promise((resolve, reject) => {
          const img = new Image();
          img.crossOrigin = 'anonymous';

          img.onload = function () {
            try {
              const canvas = document.createElement('canvas');
              const ctx = canvas.getContext('2d');
              const width = img.width;
              const height = img.height;

              canvas.width = width;
              canvas.height = height;

              const remainderHeight = height % blockNum;

              // å°†å›¾ç‰‡åˆ‡åˆ†ä¸º blockNum å—å¹¶æ‹¼æ¥
              for (let i = 0; i < blockNum; i++) {
                let blockHeight = Math.floor(height / blockNum);
                // è®¡ç®—æºå›¾åƒä¸­å½“å‰å—çš„Yè½´èµ·ç‚¹ä½ç½®ï¼ˆä»åº•éƒ¨å¼€å§‹ï¼‰
                const srcImgYStart = height - (blockHeight * (i + 1)) - remainderHeight;
                // è®¡ç®—ç›®æ ‡å›¾åƒä¸­å½“å‰å—çš„Yè½´èµ·ç‚¹ä½ç½®ï¼ˆä»é¡¶éƒ¨å¼€å§‹ï¼‰
                let dstImgYStart = blockHeight * i;

                // ç¬¬ä¸€å—éœ€è¦åŠ ä¸Šä½™æ•°é«˜åº¦
                if (i === 0) {
                  blockHeight += remainderHeight;
                } else {
                  dstImgYStart += remainderHeight;
                }

                // å¤åˆ¶å½“å‰å—
                ctx.drawImage(
                  img,
                  0, srcImgYStart, width, blockHeight,  // æºå›¾åƒåŒºåŸŸ
                  0, dstImgYStart, width, blockHeight   // ç›®æ ‡å›¾åƒåŒºåŸŸ
                );
              }

              // å°† Canvas è½¬æ¢ä¸º Blob URL
              canvas.toBlob((blob) => {
                if (blob) {
                  const url = URL.createObjectURL(blob);
                  resolve(url);
                } else {
                  reject(new Error('å›¾ç‰‡æ‹¼æ¥å¤±è´¥ï¼šæ— æ³•åˆ›å»º Blob'));
                }
              }, 'image/webp');
            } catch (error) {
              reject(new Error('å›¾ç‰‡æ‹¼æ¥å¤±è´¥: ' + error.message));
            }
          };

          img.onerror = function () {
            reject(new Error('å›¾ç‰‡åŠ è½½å¤±è´¥'));
          };

          img.src = imageUrl;
        });
      }

      // API è¯·æ±‚å‡½æ•°
      async apiRequest(path, method = 'GET', params = null, data = null, isScrambleId = false) {
        const timestamp = Math.floor(Date.now() / 1000);
        const token = this.generateToken(timestamp, isScrambleId);
        const tokenparam = `${timestamp},${this.APP_VERSION}`;

        const url = `https://${this.API_DOMAIN}${path}`;

        const config = {
          method,
          url,
          headers: {
            'token': token,
            'tokenparam': tokenparam
          },
          withCredentials: true
        };

        if (params) {
          config.params = params;
        }

        if (data && method === 'POST') {
          const formData = new URLSearchParams();
          for (const key in data) {
            formData.append(key, data[key]);
          }
          config.data = formData.toString();
          config.headers['content-type'] = 'application/x-www-form-urlencoded';
        }

        // æ‰“å°è¯·æ±‚æ—¥å¿—
        console.log(`[API Request] ${method} ${url}`, {
          params,
          data: data ? Object.keys(data).reduce((acc, key) => {
            acc[key] = key === 'password' ? '***' : data[key];
            return acc;
          }, {}) : null,
          headers: { token: token.substring(0, 8) + '...', tokenparam }
        });

        try {
          const response = await axios(config);

          // æ‰“å°å“åº”æ—¥å¿—
          console.log(`[API Response] ${method} ${url}`, {
            status: response.status,
            code: response.data?.code,
            dataSize: response.data ? JSON.stringify(response.data).length : 0,
            data: response.data
          });

          if (response.data && response.data.code !== undefined) {
            if (response.data.code !== 200) {
              throw new Error(`API è¿”å›é”™è¯¯: code=${response.data.code}, message=${response.data.msg || 'æœªçŸ¥é”™è¯¯'}`);
            }

            if (typeof response.data.data === 'string' && response.data.data) {
              try {
                const decrypted = this.decryptData(timestamp, response.data.data);
                response.data.data = JSON.parse(decrypted);
                console.log(`[API Decrypted] ${path}`, response.data.data);
              } catch (e) {
                try {
                  response.data.data = JSON.parse(response.data.data);
                } catch (e2) {
                  // ä¿æŒåŸæ ·
                }
              }
            }
          }

          return response.data;
        } catch (error) {
          console.error(`[API Error] ${method} ${url}`, {
            message: error.message,
            response: error.response?.data,
            status: error.response?.status
          });
          if (error.response) {
            const status = error.response.status;
            if (status === 401) {
              throw new Error('æœªæˆæƒï¼šè¯·å…ˆç™»å½•æˆ– Cookie å·²è¿‡æœŸ');
            }
            throw new Error(`HTTP ${status}: ${error.response.statusText || ''}`);
          } else if (error.request) {
            throw new Error('ç½‘ç»œè¯·æ±‚å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥');
          } else {
            throw error;
          }
        }
      }

      // ç™»å½•
      async login(username, password) {
        const timestamp = Math.floor(Date.now() / 1000);
        const token = this.generateToken(timestamp);
        const tokenparam = `${timestamp},${this.APP_VERSION}`;

        const formDataObj = new URLSearchParams();
        formDataObj.append('username', username);
        formDataObj.append('password', password);

        const response = await axios({
          method: 'POST',
          url: `https://${this.API_DOMAIN}/login`,
          data: formDataObj.toString(),
          headers: {
            'token': token,
            'tokenparam': tokenparam,
            'content-type': 'application/x-www-form-urlencoded'
          },
          withCredentials: true
        });

        let responseData = response.data;
        if (responseData.code !== 200) {
          throw new Error(`API è¿”å›é”™è¯¯: code=${responseData.code}`);
        }

        if (typeof responseData.data === 'string' && responseData.data) {
          const decrypted = this.decryptData(timestamp, responseData.data);
          responseData.data = JSON.parse(decrypted);
        }

        const userData = responseData.data;

        if (userData.photo && !userData.photo.startsWith('http')) {
          userData.photo = `https://${this.IMAGE_DOMAIN}/media/users/${userData.photo}`;
        }

        // ä¿å­˜ session å’Œç”¨æˆ·ä¿¡æ¯åˆ° localStorage
        if (userData.s) {
          localStorage.setItem('comic_session', userData.s);
        }
        localStorage.setItem('comic_user', JSON.stringify(userData));

        return userData;
      }

      // è·å–ç”¨æˆ·ä¿¡æ¯
      async getUserProfile() {
        const response = await this.apiRequest('/login', 'POST');

        if (response.code !== 200) {
          if (response.code === 401 || response.msg?.includes('ç™»å½•') || response.msg?.includes('æœªæˆæƒ')) {
            throw new Error('æœªæˆæƒï¼šCookie æ— æ•ˆæˆ–å·²è¿‡æœŸï¼Œè¯·é‡æ–°ç™»å½•');
          }
          throw new Error(`API è¿”å›é”™è¯¯: code=${response.code}, msg=${response.msg || 'æœªçŸ¥é”™è¯¯'}`);
        }

        let userData = response.data;
        if (!userData) {
          throw new Error('è·å–ç”¨æˆ·ä¿¡æ¯å¤±è´¥ï¼šè¿”å›æ•°æ®ä¸ºç©º');
        }

        if (userData.photo && !userData.photo.startsWith('http')) {
          userData.photo = `https://${this.IMAGE_DOMAIN}/media/users/${userData.photo}`;
        }

        if (userData.s) {
          localStorage.setItem('comic_session', userData.s);
        }
        localStorage.setItem('comic_user', JSON.stringify(userData));

        return userData;
      }

      // æœç´¢æ¼«ç”»
      async search(keyword, page = 1, sort = 'Latest') {
        const params = {
          main_tag: 0,
          search_query: keyword,
          page: page,
          o: sort
        };

        console.log('[Search] æœç´¢å‚æ•°:', params);
        const response = await this.apiRequest('/search', 'GET', params);
        console.log('[Search] å“åº”æ•°æ®:', response);

        // è¿”å›å®Œæ•´å“åº”ï¼Œè®©è°ƒç”¨è€…å¤„ç†æ•°æ®ç»“æ„
        return response;
      }

      // è·å–æ¼«ç”»è¯¦æƒ…
      async getComic(aid) {
        const params = { id: aid };
        const response = await this.apiRequest('/album', 'GET', params);
        return response.data || response;
      }

      // è·å–ç« èŠ‚å›¾ç‰‡åˆ—è¡¨
      async getChapterImages(chapterId) {
        // 1. è·å– scramble_id
        const timestamp = Math.floor(Date.now() / 1000);
        const scrambleToken = this.generateToken(timestamp, true);
        const scrambleTokenparam = `${timestamp},${this.APP_VERSION}`;

        const scrambleParams = {
          id: chapterId,
          v: timestamp,
          mode: 'vertical',
          page: 0,
          app_img_shunt: 1,
          express: 'off'
        };

        let scrambleId = 220980; // é»˜è®¤å€¼
        try {
          const scrambleResponse = await axios({
            method: 'GET',
            url: `https://${this.API_DOMAIN}/chapter_view_template`,
            params: scrambleParams,
            headers: {
              'token': scrambleToken,
              'tokenparam': scrambleTokenparam
            },
            withCredentials: true
          });

          // ä»å“åº”ä¸­æå– scramble_id
          const body = scrambleResponse.data;
          const match = body.match(/var scramble_id = (\d+);/);
          if (match) {
            scrambleId = parseInt(match[1]);
          }
        } catch (e) {
          console.warn('è·å– scramble_id å¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤å€¼:', e);
        }

        // 2. è·å–ç« èŠ‚ä¿¡æ¯
        const chapterParams = { id: chapterId };
        const chapterResponse = await this.apiRequest('/chapter', 'GET', chapterParams);

        // å¤„ç†å“åº”æ•°æ®ç»“æ„
        let chapterData;
        if (chapterResponse.data && typeof chapterResponse.data === 'object' && !Array.isArray(chapterResponse.data)) {
          chapterData = chapterResponse.data;
        } else if (chapterResponse.images) {
          chapterData = chapterResponse;
        } else {
          chapterData = chapterResponse.data || chapterResponse;
        }

        if (!chapterData || !chapterData.images || !Array.isArray(chapterData.images)) {
          if (chapterData.images && Array.isArray(chapterData.images) && chapterData.images.length === 0) {
            throw new Error('ç« èŠ‚å›¾ç‰‡åˆ—è¡¨ä¸ºç©ºã€‚å¯èƒ½çš„åŸå› ï¼š1) éœ€è¦ç™»å½•æ‰èƒ½æŸ¥çœ‹æ­¤ç« èŠ‚ï¼›2) ç« èŠ‚ ID ä¸æ­£ç¡®ï¼›3) è¯¥ç« èŠ‚ç¡®å®æ²¡æœ‰å›¾ç‰‡');
          }
          throw new Error(`ç« èŠ‚æ•°æ®ä¸­æ²¡æœ‰å›¾ç‰‡åˆ—è¡¨ã€‚è¿”å›çš„æ•°æ®: ${JSON.stringify(chapterData).substring(0, 200)}`);
        }

        if (chapterData.images.length === 0) {
          throw new Error('è¯¥ç« èŠ‚æ²¡æœ‰å›¾ç‰‡ã€‚å¯èƒ½çš„åŸå› ï¼š1) éœ€è¦ç™»å½•æ‰èƒ½æŸ¥çœ‹æ­¤ç« èŠ‚ï¼›2) ç« èŠ‚ ID ä¸æ­£ç¡®ï¼›3) è¯¥ç« èŠ‚ç¡®å®æ²¡æœ‰å›¾ç‰‡');
        }

        // 3. æ„é€ å›¾ç‰‡ URL åˆ—è¡¨ï¼Œå¹¶è®¡ç®—æ¯å¼ å›¾ç‰‡çš„ block_num
        const images = chapterData.images.map((filename, index) => {
          const url = `https://${this.IMAGE_DOMAIN}/media/photos/${chapterId}/${filename}`;
          const filenameWithoutExt = filename.replace(/\.[^/.]+$/, '');
          const blockNum = this.calculateBlockNum(scrambleId, chapterId, filenameWithoutExt);
          return {
            url,
            filename,
            filenameWithoutExt,
            blockNum,
            index: index + 1,
            processedUrl: null,
            isProcessing: false
          };
        });

        return {
          chapterId,
          scrambleId,
          images,
          total: images.length
        };
      }

      // å¤„ç†å›¾ç‰‡æ‹¼æ¥ï¼ˆå¦‚æœéœ€è¦ï¼‰
      async processImage(image) {
        // å¦‚æœå·²ç»æœ‰å¤„ç†è¿‡çš„URLï¼ˆblob URLï¼‰ï¼Œç›´æ¥è¿”å›
        if (image.processedUrl && image.processedUrl.startsWith('blob:')) {
          return image.processedUrl;
        }

        if (image.blockNum === 0) {
          image.processedUrl = image.url;
          return image.url;
        }

        if (image.isProcessing) {
          // å¦‚æœæ­£åœ¨å¤„ç†ä¸­ï¼Œè¿”å›åŸå§‹URLï¼ˆé¿å…é‡å¤å¤„ç†ï¼‰
          return image.url;
        }

        image.isProcessing = true;
        try {
          const processedUrl = await this.stitchImage(image.url, image.blockNum);
          // åªæœ‰æˆåŠŸè¿”å›blob URLæ—¶æ‰è®¾ç½® processedUrl
          if (processedUrl && processedUrl.startsWith('blob:')) {
            image.processedUrl = processedUrl;
            return processedUrl;
          } else {
            // å¦‚æœè¿”å›çš„ä¸æ˜¯blob URLï¼Œè¯´æ˜è§£ç å¤±è´¥
            console.warn('å›¾ç‰‡æ‹¼æ¥è¿”å›çš„ä¸æ˜¯blob URL:', processedUrl?.substring(0, 50));
            // ä¸è®¾ç½® processedUrlï¼Œå…è®¸ä¸‹æ¬¡é‡è¯•
            return image.url;
          }
        } catch (error) {
          console.error('å›¾ç‰‡æ‹¼æ¥å¤±è´¥:', error);
          // ä¸è®¾ç½® processedUrl ä¸ºåŸå§‹URLï¼Œå…è®¸ä¸‹æ¬¡é‡è¯•
          return image.url;
        } finally {
          image.isProcessing = false;
        }
      }

      // è·å–æ”¶è—å¤¹
      async getFavoriteFolder(folderId = 0, page = 1, sort = 'FavoriteTime') {
        const params = {
          folder_id: folderId,
          page: page,
          o: sort
        };
        const response = await this.apiRequest('/favorite', 'GET', params);
        return response.data || response;
      }

      // è·å–æ¯å‘¨å¿…çœ‹ä¿¡æ¯
      async getWeeklyInfo() {
        const response = await this.apiRequest('/week', 'GET');
        return response.data || response;
      }

      // è·å–æ¯å‘¨å¿…çœ‹
      async getWeekly(categoryId, typeId) {
        const params = {
          category_id: categoryId,
          type_id: typeId
        };
        const response = await this.apiRequest('/week/filter', 'GET', params);
        return response.data || response;
      }
    }

    // ==================== åˆ›å»ºå…¨å±€ API å®ä¾‹ ====================
    let comicAPI = null;

    const app = createApp({
      setup() {
        // --- çŠ¶æ€ç®¡ç† ---
        const loading = ref(false); // å·¦ä¾§åˆ—è¡¨åŠ è½½çŠ¶æ€
        const detailLoading = ref(false); // è¯¦æƒ…é¡µåŠ è½½çŠ¶æ€
        const searchQuery = ref('');
        const showSettings = ref(false);

        // Message API - ä½¿ç”¨ createDiscreteApi åˆ›å»ºç‹¬ç«‹å®ä¾‹ï¼ˆä¸éœ€è¦ n-message-providerï¼‰
        let messageApi = null;
        try {
          if (naive.createDiscreteApi) {
            const { message: discreteMessage } = naive.createDiscreteApi(['message']);
            messageApi = discreteMessage;
            window.$message = discreteMessage;
          }
        } catch (e) {
          console.warn('æ— æ³•åˆ›å»ºç¦»æ•£æ¶ˆæ¯ API:', e);
        }

        const message = {
          success: (msg) => {
            if (messageApi) {
              messageApi.success(msg);
            } else if (window.$message) {
              window.$message.success(msg);
            } else {
              console.log('[Success]', msg);
            }
          },
          error: (msg) => {
            if (messageApi) {
              messageApi.error(msg);
            } else if (window.$message) {
              window.$message.error(msg);
            } else {
              console.error('[Error]', msg);
            }
          },
          warning: (msg) => {
            if (messageApi) {
              messageApi.warning(msg);
            } else if (window.$message) {
              window.$message.warning(msg);
            } else {
              console.warn('[Warning]', msg);
            }
          },
          info: (msg) => {
            if (messageApi) {
              messageApi.info(msg);
            } else if (window.$message) {
              window.$message.info(msg);
            } else {
              console.info('[Info]', msg);
            }
          }
        };

        // æŒä¹…åŒ–è®¾ç½®
        const settings = useStorage('jm-settings', {
          proxyUrl: '',
          apiDomain: 'www.cdnblackmyth.club',
          imageDomain: 'cdn-msp2.jmapiproxy2.cc',
          appTokenSecret: '18comicAPP',
          appTokenSecret2: '18comicAPPContent',
          appDataSecret: '185Hcomic3PAPP7R',
          appVersion: '1.7.5'
        });

        // n-select ä¸‹æ‹‰é€‰é¡¹
        const proxyUrlOptions = [
          { label: 'æœ¬åœ°ä»£ç†ï¼ˆæ¨èï¼‰', value: 'http://localhost:3000/proxy?url=' },
          { label: 'æ¸…ç©º', value: '' }
        ];

        const apiDomainOptions = [
          { label: 'www.cdnblackmyth.club', value: 'www.cdnblackmyth.club' },
          { label: 'jmcomic.me', value: 'jmcomic.me' },
          { label: 'jmcomic1.me', value: 'jmcomic1.me' }
        ];

        const imageDomainOptions = [
          { label: 'cdn-msp2.jmapiproxy2.cc', value: 'cdn-msp2.jmapiproxy2.cc' },
          { label: 'cdn-msp.jmapiproxy2.cc', value: 'cdn-msp.jmapiproxy2.cc' },
          { label: 'img.jmcomic.me', value: 'img.jmcomic.me' }
        ];

        const tokenSecretOptions = [
          { label: '18comicAPP', value: '18comicAPP' }
        ];

        const tokenSecret2Options = [
          { label: '18comicAPPContent', value: '18comicAPPContent' }
        ];

        const dataSecretOptions = [
          { label: '185Hcomic3PAPP7R', value: '185Hcomic3PAPP7R' }
        ];

        const appVersionOptions = [
          { label: '1.7.5ï¼ˆæœ€æ–°ï¼‰', value: '1.7.5' },
          { label: '1.7.4', value: '1.7.4' },
          { label: '1.7.3', value: '1.7.3' },
          { label: '1.7.2', value: '1.7.2' },
          { label: '1.7.1', value: '1.7.1' }
        ];

        // åˆå§‹åŒ– API å®ä¾‹
        if (!comicAPI) {
          comicAPI = new ComicAPI(settings.value);
        }

        // ç›‘å¬è®¾ç½®å˜åŒ–ï¼Œæ›´æ–° API é…ç½®
        watch(settings, (newSettings) => {
          if (comicAPI) {
            comicAPI.updateSettings(newSettings);
          }
        }, { deep: true });

        // åˆ†é¡µç›¸å…³
        const currentPage = ref(1);
        const hasMorePages = ref(true);
        const totalPages = ref(1);
        const totalItems = ref(0);
        const pageSize = ref(20);
        const autoLoadNextPage = useStorage('jm-auto-load-next-page', false);
        const leftPanelWidth = ref(320); // å·¦ä¾§é¢æ¿å®½åº¦ï¼ˆåƒç´ ï¼‰
        const leftPanelRef = ref(null); // å·¦ä¾§é¢æ¿å®¹å™¨å¼•ç”¨

        // ä½¿ç”¨ useStorage ä¿å­˜æœç´¢ç»“æœåˆ°æœ¬åœ°ï¼ˆä¸æ·±åº¦ç›‘å¬ï¼Œæ‰‹åŠ¨ä¿å­˜ï¼‰
        const savedSearchResults = useStorage('jm-search-results', {
          comicList: [],
          searchQuery: '',
          currentPage: 1,
          totalItems: 0,
          totalPages: 1,
          hasMorePages: true,
          timestamp: 0
        });

        // ä¿å­˜å½“å‰æŸ¥çœ‹çš„æ¼«ç”»ï¼ˆç”¨äºåˆ·æ–°åæ¢å¤ï¼‰
        const currentViewingComic = useStorage('jm-current-viewing-comic', {
          id: null,
          timestamp: 0
        });

        // ä¿å­˜å½“å‰æŸ¥çœ‹çš„ç« èŠ‚ï¼ˆç”¨äºåˆ·æ–°åæ¢å¤ï¼‰
        const currentViewingChapter = useStorage('jm-current-viewing-chapter', {
          comicId: null,
          chapterId: null,
          imageIndex: 0,
          timestamp: 0
        });

        // ç¼“å­˜ç³»ç»Ÿï¼šæ¼«ç”»è¯¦æƒ…å’Œç« èŠ‚å›¾ç‰‡åˆ—è¡¨
        const cacheStore = useStorage('jm-cache-store', {
          details: {}, // { comicId: { data: {...}, timestamp: number } }
          chapters: {} // { chapterId: { data: {...}, timestamp: number } }
        });

        // ç¼“å­˜è¿‡æœŸæ—¶é—´ï¼ˆæ¯«ç§’ï¼‰ï¼š24å°æ—¶
        const CACHE_EXPIRY_TIME = 24 * 60 * 60 * 1000;

        // ç¼“å­˜å·¥å…·å‡½æ•°
        const cacheUtils = {
          // è·å–ç¼“å­˜
          get(key, type = 'details') {
            const cache = cacheStore.value[type];
            if (!cache || !cache[key]) return null;

            const cached = cache[key];
            const now = Date.now();

            // æ£€æŸ¥æ˜¯å¦è¿‡æœŸ
            if (now - cached.timestamp > CACHE_EXPIRY_TIME) {
              // ç¼“å­˜å·²è¿‡æœŸï¼Œåˆ é™¤
              delete cache[key];
              cacheStore.value[type] = { ...cache };
              return null;
            }

            return cached.data;
          },

          // è®¾ç½®ç¼“å­˜
          set(key, data, type = 'details') {
            const cache = cacheStore.value[type];
            cacheStore.value[type] = {
              ...cache,
              [key]: {
                data: data,
                timestamp: Date.now()
              }
            };
          },

          // æ¸…é™¤ç¼“å­˜
          clear(type = null) {
            if (type) {
              cacheStore.value[type] = {};
            } else {
              cacheStore.value = { details: {}, chapters: {} };
            }
          },

          // æ¸…é™¤è¿‡æœŸç¼“å­˜
          clearExpired() {
            const now = Date.now();
            ['details', 'chapters'].forEach(type => {
              const cache = cacheStore.value[type];
              const keys = Object.keys(cache);
              let hasChanges = false;

              keys.forEach(key => {
                if (now - cache[key].timestamp > CACHE_EXPIRY_TIME) {
                  delete cache[key];
                  hasChanges = true;
                }
              });

              if (hasChanges) {
                cacheStore.value[type] = { ...cache };
              }
            });
          }
        };

        // ä¿å­˜æœç´¢ç»“æœåˆ°æœ¬åœ°å­˜å‚¨
        const saveSearchResults = () => {
          savedSearchResults.value = {
            comicList: [...comicList.value],
            searchQuery: searchQuery.value,
            currentPage: currentPage.value,
            totalItems: totalItems.value,
            totalPages: totalPages.value,
            hasMorePages: hasMorePages.value,
            timestamp: Date.now()
          };
        };

        // å“åº”å¼åˆ—æ•°è®¡ç®—
        const leftColumnCount = computed(() => {
          // æ ¹æ®å·¦ä¾§é¢æ¿å®½åº¦è®¡ç®—åˆ—æ•°
          // æ¯åˆ—æœ€å°å®½åº¦ä¸º 200pxï¼ˆåŒ…æ‹¬gapï¼‰
          const minColumnWidth = 200;
          // è®¡ç®—å¯ç”¨å®½åº¦ï¼ˆè€ƒè™‘ padding 16pxï¼Œå·¦å³å„8pxï¼‰
          const availableWidth = leftPanelWidth.value - 16;
          // å¦‚æœå¯ç”¨å®½åº¦å°äºæœ€å°å®½åº¦ï¼Œè¿”å›1åˆ—
          if (availableWidth < minColumnWidth) {
            return 1;
          }
          // è®¡ç®—åˆ—æ•°
          const columns = Math.floor(availableWidth / minColumnWidth);
          return Math.max(1, Math.min(columns, 10)); // æœ€å°‘1åˆ—ï¼Œæœ€å¤š5åˆ—
        });

        // å³ä¾§ Tab
        const rightTab = ref('detail');

        // åˆ†å‰²é¢æ¿å¤§å°æ§åˆ¶ï¼š1 è¡¨ç¤ºåªæ˜¾ç¤ºå·¦ä¾§ï¼Œ0 è¡¨ç¤ºåªæ˜¾ç¤ºå³ä¾§ï¼Œ0.5 è¡¨ç¤ºå·¦å³å„ä¸€åŠ
        const splitSize = ref(1);

        // å›¾ç‰‡ç¼©æ”¾æ¯”ä¾‹ï¼ˆç™¾åˆ†æ¯”ï¼‰
        const imageScale = ref(100);

        // ä¼°ç®—çš„å›¾ç‰‡é«˜åº¦ï¼ˆç”¨äºè™šæ‹Ÿåˆ—è¡¨ï¼‰ï¼Œåˆå§‹ç»™ä¸€ä¸ªç•¥å¤§ä¸€ç‚¹çš„å€¼
        const estimatedImageHeight = ref(1000);
        const hasMeasuredImageHeight = ref(false);

        // æ•°æ®æ¨¡å‹
        const comicList = ref([]);
        const currentComic = ref({});
        const chapterList = ref([]);
        const currentChapter = ref({});
        const readingImages = ref([]);
        const currentImageIndex = ref(0); // å½“å‰æŸ¥çœ‹çš„å›¾ç‰‡ç´¢å¼•
        const imageListRef = ref(null); // n-virtual-list å¼•ç”¨
        // å½“å‰ç« èŠ‚çš„å›¾ç‰‡å¯¹è±¡åˆ—è¡¨ï¼ˆå“åº”å¼ï¼‰
        const currentChapterImages = ref([]);

        // é˜…è¯»è¿›åº¦ slider ä»£ç†ï¼Œæ‹–åŠ¨æ—¶åŒæ­¥æ»šåŠ¨åˆ°å¯¹åº”å›¾ç‰‡
        const currentImageIndexProxy = computed({
          get() {
            return currentImageIndex.value;
          },
          set(value) {
            if (!readingImages.value.length) return;
            const maxIndex = Math.max(0, readingImages.value.length - 1);
            const targetIndex = Math.min(Math.max(0, value), maxIndex);
            if (targetIndex === currentImageIndex.value) return;
            currentImageIndex.value = targetIndex;

            // ä½¿ç”¨ Virtual List å®˜æ–¹ scrollTo API æ»šåŠ¨åˆ°å¯¹åº”å›¾ç‰‡
            if (imageListRef.value && imageListRef.value.scrollTo) {
              imageListRef.value.scrollTo({ index: targetIndex, behavior: 'smooth' });
            }
          }
        });

        // è™šæ‹Ÿåˆ—è¡¨æ»šåŠ¨æ—¶ï¼Œæ ¹æ® scrollTop ç²—ç•¥è®¡ç®—å½“å‰å›¾ç‰‡ç´¢å¼•
        // Naive UI Virtual List çš„ on-scroll å›è°ƒç­¾åç±»ä¼¼äº { scrollTop, scrollLeft }
        const handleImageListScroll = (pos) => {
          if (!readingImages.value.length) return;
          const scrollTop = (pos && typeof pos.scrollTop === 'number') ? pos.scrollTop : 0;

          // Virtual List å†…éƒ¨ä¼šè‡ªåŠ¨å¤„ç†å®¹å™¨é«˜åº¦ï¼Œæˆ‘ä»¬ç”¨é¢„ä¼°é«˜åº¦æ¥è¿‘ä¼¼è®¡ç®—ç´¢å¼•å³å¯
          const avgHeight = estimatedImageHeight.value || 800;
          const containerHeight = avgHeight; // ç®€å•è¿‘ä¼¼ï¼Œè§†å£é«˜åº¦çº¦ç­‰äºä¸€å¼ å›¾é«˜åº¦

          // ä½¿ç”¨è§†å£ä¸­çº¿çš„ä½ç½®æ¥ä¼°ç®—å½“å‰å›¾ç‰‡ç´¢å¼•
          let index = Math.round((scrollTop + containerHeight / 2) / avgHeight);
          index = Math.max(0, Math.min(readingImages.value.length - 1, index));

          if (index !== currentImageIndex.value) {
            currentImageIndex.value = index;

            // åŒæ­¥ä¿å­˜åˆ° localStorage
            if (currentChapter.value && currentChapter.value.id && currentComic.value && currentComic.value.id) {
              currentViewingChapter.value = {
                comicId: currentComic.value.id,
                chapterId: currentChapter.value.id,
                imageIndex: index,
                timestamp: Date.now()
              };
            }
          }
        };

        // --- æ ¸å¿ƒé€»è¾‘ï¼šå¤„ç†å°é¢å›¾ URL ---
        const processCoverUrl = (image, albumId) => {
          const imageDomain = settings.value.imageDomain || comicAPI.IMAGE_DOMAIN;

          if (!image) {
            // å¦‚æœæ²¡æœ‰å›¾ç‰‡ï¼Œä½¿ç”¨é»˜è®¤æ ¼å¼
            if (albumId) {
              return `https://${imageDomain}/media/albums/${albumId}_3x4.jpg`;
            }
            return '';
          }

          // å¦‚æœå·²ç»æ˜¯å®Œæ•´URLï¼Œç›´æ¥è¿”å›
          if (image.startsWith('http://') || image.startsWith('https://')) {
            return image;
          }

          // å¦‚æœæ˜¯ç›¸å¯¹è·¯å¾„ï¼Œæ‹¼æ¥å®Œæ•´URL
          // å¤„ç†ä¸åŒçš„ç›¸å¯¹è·¯å¾„æ ¼å¼ï¼š
          // - "albums/123456_3x4.jpg" -> "https://domain/media/albums/123456_3x4.jpg"
          // - "123456_3x4.jpg" -> "https://domain/media/albums/123456_3x4.jpg"
          // - "media/albums/123456_3x4.jpg" -> "https://domain/media/albums/123456_3x4.jpg"
          if (image.startsWith('media/')) {
            return `https://${imageDomain}/${image}`;
          } else if (image.startsWith('albums/')) {
            return `https://${imageDomain}/media/${image}`;
          } else if (albumId) {
            // å¦‚æœåªæ˜¯æ–‡ä»¶åï¼Œä½¿ç”¨é»˜è®¤æ ¼å¼
            return `https://${imageDomain}/media/albums/${albumId}_3x4.jpg`;
          } else {
            // å°è¯•ç›´æ¥æ‹¼æ¥
            return `https://${imageDomain}/media/albums/${image}`;
          }
        };

        // --- æ ¸å¿ƒé€»è¾‘ï¼šä»£ç† URL ç”Ÿæˆ ---
        const getProxiedUrl = (url, isImage = false) => {
          if (!url) return '';
          // å¦‚æœæ˜¯æœ¬åœ° Mock æ•°æ®æˆ– blob URLï¼ˆæ‹¼æ¥åçš„å›¾ç‰‡ï¼‰ï¼Œç›´æ¥è¿”å›
          if (url.startsWith('data:') || url.startsWith('blob:') || url.includes('placeholder')) return url;

          // å¦‚æœç”¨æˆ·é…ç½®äº†ä»£ç†ï¼Œä½¿ç”¨ä»£ç†
          if (settings.value.proxyUrl) {
            const separator = settings.value.proxyUrl.includes('?') ? '&' : '?';
            const typeParam = isImage ? '&type=image' : '';
            return `${settings.value.proxyUrl}${encodeURIComponent(url)}${typeParam}`;
          }

          // å¦‚æœæ²¡æœ‰ä»£ç†ï¼Œè¿”å›åŸå§‹ URL (é€šå¸¸ä¼š 403ï¼Œé™¤éå®‰è£…äº†æµè§ˆå™¨å Referer æ’ä»¶)
          return url;
        };

        // --- æ¨¡æ‹Ÿæ•°æ® (Mock Data) ç”¨äºæ¼”ç¤º ---
        const mockComics = [
          { id: '452830', title: 'ã€æ¼”ç¤ºæ•°æ®ã€‘å¼‚ä¸–ç•Œåå®«ç”Ÿæ´»', author: 'JMä½œè€…', date: '2023-10-20', cover: 'https://placehold.co/400x600/222/FFF/png?text=Cover+1', description: 'è¿™æ˜¯ä¸€ä¸ªçº¯å‰ç«¯æ¼”ç¤ºï¼Œå› ä¸ºæ²¡æœ‰é…ç½®ä»£ç†ï¼Œä½¿ç”¨çš„æ˜¯æ¨¡æ‹Ÿæ•°æ®ã€‚è¯·åœ¨è®¾ç½®ä¸­é…ç½®ä»£ç†ä»¥è®¿é—®çœŸå®æ•°æ®ã€‚' },
          { id: '339912', title: 'ã€æ¼”ç¤ºæ•°æ®ã€‘æ™®é€šçš„æ‹çˆ±æ•…äº‹', author: 'Unknown', date: '2023-10-18', cover: 'https://placehold.co/400x600/333/FFF/png?text=Cover+2', description: 'æ¨¡æ‹Ÿæ•°æ®...' },
          { id: '123456', title: 'ã€æ¼”ç¤ºæ•°æ®ã€‘æµ‹è¯•æ¼«ç”»æ¡ç›®', author: 'Test', date: '2023-10-15', cover: 'https://placehold.co/400x600/444/FFF/png?text=Cover+3', description: 'æ¨¡æ‹Ÿæ•°æ®...' },
        ];

        // --- ä¸šåŠ¡åŠŸèƒ½ ---

        const goHome = () => {
          if (comicList.value.length === 0) loadMockData();
        };

        const loadMockData = () => {
          loading.value = true;
          setTimeout(() => {
            comicList.value = mockComics;
            currentPage.value = 1;
            hasMorePages.value = false;
            loading.value = false;
            // ä¿å­˜æ¨¡æ‹Ÿæ•°æ®åˆ°æœ¬åœ°å­˜å‚¨
            saveSearchResults();
          }, 500);
        };

        // å¤„ç†æœç´¢å“åº”æ•°æ®
        const processSearchResponse = (response) => {
          let data = response.data || response;
          let items = [];

          if (data && data.content && Array.isArray(data.content)) {
            items = data.content;
            // å°è¯•ä»å“åº”ä¸­è·å–æ€»æ•°å’Œé¡µæ•°
            if (data.total) {
              const total = parseInt(data.total) || 0;
              totalItems.value = total;
              totalPages.value = Math.ceil(total / pageSize.value);
            } else {
              // å¦‚æœæ²¡æœ‰æ€»æ•°ï¼Œæ ¹æ®å½“å‰é¡µæ•°æ®ä¼°ç®—
              totalItems.value = items.length * currentPage.value;
              totalPages.value = currentPage.value + (items.length === pageSize.value ? 1 : 0);
            }
          } else if (data && data.list && Array.isArray(data.list)) {
            items = data.list;
            totalItems.value = items.length;
            totalPages.value = Math.ceil(items.length / pageSize.value);
          } else if (Array.isArray(data)) {
            items = data;
            totalItems.value = items.length;
            totalPages.value = Math.ceil(items.length / pageSize.value);
          }

          return items.map(item => {
            const albumId = item.id || item.aid || item.album_id;
            const rawImage = item.image || item.thumb || item.cover || item.thumb_url || '';
            return {
              id: albumId,
              title: item.name || item.title || 'æœªçŸ¥æ ‡é¢˜',
              author: item.author || item.author_name || 'æœªçŸ¥ä½œè€…',
              date: item.update_at ? new Date(item.update_at * 1000).toLocaleDateString() : '',
              cover: processCoverUrl(rawImage, albumId),
              description: item.description || item.intro || '',
              tags: item.tags || []
            };
          });
        };

        const handleSearch = async (page = 1, append = false) => {
          if (!searchQuery.value && page === 1) {
            // å¦‚æœæ²¡æœ‰æœç´¢è¯ï¼Œå¯ä»¥åŠ è½½æ¨èæˆ–çƒ­é—¨å†…å®¹
            loadMockData();
            return;
          }

          if (page === 1 && !append) {
            comicList.value = [];
            currentPage.value = 1;
            hasMorePages.value = true;
          }

          loading.value = true;
          try {
            const response = await comicAPI.search(searchQuery.value || '', page, 'Latest');
            console.log('[handleSearch] å®Œæ•´å“åº”:', response);

            const newItems = processSearchResponse(response);

            if (append) {
              comicList.value = [...comicList.value, ...newItems];
            } else {
              comicList.value = newItems;
            }

            // åˆ¤æ–­æ˜¯å¦è¿˜æœ‰æ›´å¤šé¡µ
            if (newItems.length === 0 || currentPage.value >= totalPages.value) {
              hasMorePages.value = false;
            } else {
              hasMorePages.value = true;
            }

            // ä¿å­˜æœç´¢ç»“æœåˆ°æœ¬åœ°å­˜å‚¨
            saveSearchResults();
          } catch (error) {
            console.error('[handleSearch] æœç´¢å¤±è´¥:', error);
            if (message) {
              message.error('æœç´¢å¤±è´¥: ' + error.message);
            }
            if (!append) {
              comicList.value = [];
            }
            // å³ä½¿å¤±è´¥ä¹Ÿä¿å­˜å½“å‰çŠ¶æ€
            saveSearchResults();
          } finally {
            loading.value = false;
          }
        };

        // åŠ è½½ä¸‹ä¸€é¡µï¼ˆç”¨äºæ— é™æ»šåŠ¨ï¼‰
        const loadNextPage = async () => {
          console.log('loadNextPage');

          if (loading.value || !hasMorePages.value) {
            return Promise.resolve();
          }
          currentPage.value++;
          await handleSearch(currentPage.value, true);
        };

        // å¤„ç†æ— é™æ»šåŠ¨åŠ è½½ï¼ˆç”¨äº n-infinite-scroll ç»„ä»¶ï¼‰
        // å‚è€ƒå®˜æ–¹ç¤ºä¾‹ï¼šæ£€æŸ¥ loading å’Œ noMore çŠ¶æ€ï¼Œé˜²æ­¢é‡å¤è§¦å‘
        const handleLoad = async () => {
          // å¦‚æœæ­£åœ¨åŠ è½½æˆ–æ²¡æœ‰æ›´å¤šé¡µé¢ï¼Œç›´æ¥è¿”å›ï¼ˆå‚è€ƒå®˜æ–¹ç¤ºä¾‹ï¼‰
          if (loading.value || !hasMorePages.value) {
            return;
          }

          // å¦‚æœè‡ªåŠ¨åŠ è½½æœªå¯ç”¨ï¼Œç›´æ¥è¿”å›
          if (!autoLoadNextPage.value) {
            return;
          }

          // handleSearch ä¼šç®¡ç† loading çŠ¶æ€ï¼Œè¿™é‡Œä¸éœ€è¦è®¾ç½®
          try {
            currentPage.value++;
            // è¿½åŠ æ¨¡å¼åŠ è½½ä¸‹ä¸€é¡µ
            await handleSearch(currentPage.value, true);
          } catch (error) {
            console.error('[handleLoad] åŠ è½½å¤±è´¥:', error);
            // åŠ è½½å¤±è´¥æ—¶å›é€€é¡µç 
            currentPage.value--;
            if (message) {
              message.error('åŠ è½½å¤±è´¥: ' + error.message);
            }
          } finally {
            // ç¡®ä¿åŠ è½½æ›´å¤šæ—¶ä¹Ÿä¿å­˜ç»“æœï¼ˆhandleSearch å·²ç»ä¿å­˜ï¼Œè¿™é‡Œä½œä¸ºåŒé‡ä¿é™©ï¼‰
            saveSearchResults();
          }
          // handleSearch ä¼šåœ¨ finally ä¸­è‡ªåŠ¨è®¾ç½® loading.value = false
        };

        // åˆ†é¡µå˜åŒ–å¤„ç†
        const handlePageChange = (page) => {
          currentPage.value = page;
          handleSearch(page, false);
        };

        // æ¯é¡µæ•°é‡å˜åŒ–å¤„ç†
        const handlePageSizeChange = (size) => {
          pageSize.value = size;
          currentPage.value = 1;
          handleSearch(1, false);
        };


        // æ›´æ–°å·¦ä¾§é¢æ¿å®½åº¦
        const updateLeftPanelWidth = () => {
          if (leftPanelRef.value) {
            let panelEl = null;
            if (leftPanelRef.value instanceof HTMLElement) {
              panelEl = leftPanelRef.value;
            } else if (leftPanelRef.value && typeof leftPanelRef.value === 'object' && '$el' in leftPanelRef.value) {
              panelEl = leftPanelRef.value.$el;
            } else if (leftPanelRef.value && typeof leftPanelRef.value === 'object' && 'el' in leftPanelRef.value) {
              panelEl = leftPanelRef.value.el;
            }

            if (panelEl && panelEl instanceof HTMLElement) {
              leftPanelWidth.value = panelEl.offsetWidth || 320;
              console.log('[Layout] å·¦ä¾§é¢æ¿å®½åº¦æ›´æ–°:', leftPanelWidth.value, 'åˆ—æ•°:', leftColumnCount.value);
            }
          }
        };

        // ç›‘å¬çª—å£å¤§å°å˜åŒ–
        const handleResize = () => {
          updateLeftPanelWidth();
        };

        // åˆ‡æ¢å³ä¾§é¢æ¿æ˜¾ç¤º/éšè—
        const toggleRightPanel = () => {
          splitSize.value = splitSize.value === 1 ? 0.5 : 1;
        };

        // åˆ‡æ¢å·¦ä¾§é¢æ¿æ˜¾ç¤º/éšè—
        const toggleLeftPanel = () => {
          splitSize.value = splitSize.value === 0 ? 0.5 : 0;
        };

        // å¤„ç†é”®ç›˜äº‹ä»¶ï¼šTab é”®å¿«é€ŸæŠ˜å /å±•å¼€
        const handleKeyDown = (event) => {
          // å¦‚æœæŒ‰ä¸‹ Tab é”®ï¼Œä¸”ç„¦ç‚¹ä¸åœ¨è¾“å…¥æ¡†ä¸­
          if (event.key === 'Tab' && !event.shiftKey && !event.ctrlKey && !event.altKey && !event.metaKey) {
            const activeElement = document.activeElement;
            const isInputFocused = activeElement && (
              activeElement.tagName === 'INPUT' ||
              activeElement.tagName === 'TEXTAREA' ||
              activeElement.isContentEditable ||
              activeElement.closest('input') ||
              activeElement.closest('textarea')
            );

            // å¦‚æœç„¦ç‚¹ä¸åœ¨è¾“å…¥æ¡†ä¸­ï¼Œåˆ™åˆ‡æ¢é¢æ¿å¹¶é˜»æ­¢é»˜è®¤è¡Œä¸º
            if (!isInputFocused) {
              event.preventDefault();
              toggleRightPanel();
            }
          }
        };

        const viewDetail = async (comic) => {
          currentComic.value = comic;
          chapterList.value = [];
          currentChapter.value = {};
          readingImages.value = [];
          rightTab.value = 'detail';
          // æ˜¾ç¤ºå³ä¾§é¢æ¿
          splitSize.value = 0.5;
          detailLoading.value = true;

          try {
            const comicId = comic.id;

            // ä¿å­˜å½“å‰æŸ¥çœ‹çš„æ¼«ç”»ID
            currentViewingComic.value = {
              id: comicId,
              timestamp: Date.now()
            };

            // å…ˆæ£€æŸ¥ç¼“å­˜
            let detail = cacheUtils.get(comicId, 'details');

            if (detail) {
              console.log('[Cache] ä½¿ç”¨ç¼“å­˜çš„æ¼«ç”»è¯¦æƒ…:', comicId, detail);
              // ç¡®ä¿ detail æ˜¯å¯¹è±¡
              if (typeof detail !== 'object' || detail === null) {
                console.warn('[Cache] ç¼“å­˜æ•°æ®æ ¼å¼é”™è¯¯ï¼Œé‡æ–°è·å–:', comicId);
                detail = null;
              }
            } else {
              console.log('[Cache] ç¼“å­˜æœªå‘½ä¸­ï¼Œä»APIè·å–:', comicId);
            }

            // å¦‚æœç¼“å­˜ä¸­æ²¡æœ‰æˆ–æ ¼å¼é”™è¯¯ï¼Œä»APIè·å–
            if (!detail) {
              try {
                detail = await comicAPI.getComic(comicId);
                // ä¿å­˜åˆ°ç¼“å­˜
                if (detail && typeof detail === 'object') {
                  cacheUtils.set(comicId, detail, 'details');
                  console.log('[Cache] å·²ç¼“å­˜æ¼«ç”»è¯¦æƒ…:', comicId);
                }
              } catch (error) {
                console.error('[Cache] è·å–æ¼«ç”»è¯¦æƒ…å¤±è´¥:', error);
                throw error;
              }
            }

            // æ›´æ–°æ¼«ç”»è¯¦æƒ…
            if (detail && typeof detail === 'object') {
              const albumId = detail.id || comic.id;
              const rawCover = detail.thumb || detail.cover || detail.thumb_url || comic.cover || '';
              currentComic.value = {
                ...comic,
                ...detail,
                title: detail.title || comic.title,
                description: detail.description || detail.intro || comic.description,
                tags: detail.tags || detail.tag_list || comic.tags || [],
                cover: processCoverUrl(rawCover, albumId)
              };
            }

            // æå–ç« èŠ‚åˆ—è¡¨ - ä¼˜å…ˆä½¿ç”¨ series å±æ€§
            if (detail && detail.series && Array.isArray(detail.series) && detail.series.length > 0) {
              // ä½¿ç”¨ series æ•°ç»„ï¼Œsort ä½œä¸ºç« èŠ‚åç§°
              chapterList.value = detail.series.map((item) => {
                // å¦‚æœ name å­˜åœ¨ä¸”ä¸ä¸ºç©ºï¼Œä½¿ç”¨ nameï¼›å¦åˆ™ä½¿ç”¨ sort ä½œä¸ºåç§°
                let title = item.name;
                if (!title || title.trim() === '') {
                  const sortValue = item.sort || '';
                  title = sortValue ? `ç¬¬${sortValue}è¯` : 'æœªçŸ¥ç« èŠ‚';
                }
                return {
                  id: item.id || item.chapter_id,
                  title: title,
                  order: parseInt(item.sort || 0)
                };
              }).sort((a, b) => (a.order || 0) - (b.order || 0));
            } else if (detail && detail.photos && Array.isArray(detail.photos) && detail.photos.length > 0) {
              // å¤‡ç”¨æ–¹æ¡ˆï¼šä½¿ç”¨ photos
              chapterList.value = detail.photos.map((photo, index) => ({
                id: photo.id || photo.photo_id || photo.chapter_id || (index + 1),
                title: photo.title || photo.name || `ç¬¬${index + 1}è¯`,
                order: photo.order || index + 1
              })).sort((a, b) => (a.order || 0) - (b.order || 0));
            } else if (detail && detail.chapters && Array.isArray(detail.chapters) && detail.chapters.length > 0) {
              // å¤‡ç”¨æ–¹æ¡ˆï¼šä½¿ç”¨ chapters
              chapterList.value = detail.chapters.map((chapter, index) => ({
                id: chapter.id || chapter.chapter_id || (index + 1),
                title: chapter.title || chapter.name || `ç¬¬${index + 1}è¯`,
                order: chapter.order || index + 1
              })).sort((a, b) => (a.order || 0) - (b.order || 0));
            } else {
              // å¦‚æœåˆ—è¡¨ä¸ºç©ºï¼Œé»˜è®¤æ˜¾ç¤ºä¸€ä¸ªç« èŠ‚ï¼Œåç§°ä¸º"ç¬¬ä¸€ç« "ï¼ŒIDä¸ºå½“å‰æ¼«ç”»çš„ID
              const comicId = comic.id || detail?.id;
              chapterList.value = [{
                id: comicId,
                title: 'ç¬¬ä¸€ç« ',
                order: 1
              }];
            }
          } catch (error) {
            if (message) {
              message.error('è·å–æ¼«ç”»è¯¦æƒ…å¤±è´¥: ' + error.message);
            }
            chapterList.value = [];
          } finally {
            detailLoading.value = false;
          }
        };

        // é€‰æ‹©ç« èŠ‚
        const selectChapter = async (chapter) => {
          currentChapter.value = chapter;
          readingImages.value = [];
          currentChapterImages.value = []; // é‡ç½®å›¾ç‰‡å¯¹è±¡åˆ—è¡¨
          currentImageIndex.value = 0; // é‡ç½®å½“å‰å›¾ç‰‡ç´¢å¼•
          hasMeasuredImageHeight.value = false; // é‡ç½®é«˜åº¦æµ‹é‡
          rightTab.value = 'images';
          detailLoading.value = true;

          // æ¸…ç†æ—§çš„è§£ç è§‚å¯Ÿå™¨
          cleanupImageDecodeObserver();

          // æ¸…ç†æ—§çš„è§£ç è§‚å¯Ÿå™¨
          cleanupImageDecodeObserver();

          try {
            const chapterId = chapter.id;
            const comicId = currentComic.value.id;

            // ä¿å­˜å½“å‰æŸ¥çœ‹çš„ç« èŠ‚ä¿¡æ¯
            currentViewingChapter.value = {
              comicId: comicId,
              chapterId: chapterId,
              imageIndex: 0,
              timestamp: Date.now()
            };

            // å…ˆæ£€æŸ¥ç¼“å­˜
            let result = cacheUtils.get(chapterId, 'chapters');

            if (result) {
              console.log('[Cache] ä½¿ç”¨ç¼“å­˜çš„ç« èŠ‚å›¾ç‰‡åˆ—è¡¨:', chapterId, `å…±${result.images?.length || 0}å¼ å›¾ç‰‡`);
              // ç¡®ä¿ç¼“å­˜æ•°æ®æ ¼å¼æ­£ç¡®
              if (typeof result !== 'object' || !result.images || !Array.isArray(result.images)) {
                console.warn('[Cache] ç¼“å­˜æ•°æ®æ ¼å¼é”™è¯¯ï¼Œé‡æ–°è·å–:', chapterId);
                result = null;
              } else {
                // ä»ç¼“å­˜è¯»å–æ—¶ï¼Œéœ€è¦é‡ç½®å›¾ç‰‡å¤„ç†çŠ¶æ€ï¼ˆå› ä¸º blob URL ä¸èƒ½æŒä¹…åŒ–ï¼‰
                // ç¡®ä¿æ¯ä¸ªå›¾ç‰‡å¯¹è±¡éƒ½æœ‰æ‰€æœ‰å¿…è¦çš„å±æ€§
                result.images = result.images.map((img, index) => ({
                  url: img.url || `https://${comicAPI.IMAGE_DOMAIN}/media/photos/${chapterId}/${img.filename || ''}`,
                  filename: img.filename || '',
                  filenameWithoutExt: img.filenameWithoutExt || img.filename?.replace(/\.[^/.]+$/, '') || '',
                  blockNum: img.blockNum || 0,
                  index: img.index || index + 1,
                  processedUrl: null, // é‡ç½®å¤„ç†åçš„URLï¼Œéœ€è¦é‡æ–°è§£ç 
                  isProcessing: false
                }));
                console.log('[Cache] ç¼“å­˜æ•°æ®å·²å‡†å¤‡ï¼Œå‡†å¤‡è¿›è¡Œå›¾ç‰‡è§£ç ');
              }
            } else {
              console.log('[Cache] ç¼“å­˜æœªå‘½ä¸­ï¼Œä»APIè·å–:', chapterId);
            }

            // å¦‚æœç¼“å­˜ä¸­æ²¡æœ‰æˆ–æ ¼å¼é”™è¯¯ï¼Œä»APIè·å–
            if (!result) {
              try {
                result = await comicAPI.getChapterImages(chapterId);
                // ä¿å­˜åˆ°ç¼“å­˜
                if (result && result.images && Array.isArray(result.images)) {
                  cacheUtils.set(chapterId, result, 'chapters');
                  console.log('[Cache] å·²ç¼“å­˜ç« èŠ‚å›¾ç‰‡åˆ—è¡¨:', chapterId, `å…±${result.images.length}å¼ å›¾ç‰‡`);
                }
              } catch (error) {
                console.error('[Cache] è·å–ç« èŠ‚å›¾ç‰‡å¤±è´¥:', error);
                throw error;
              }
            }

            // å¤„ç†å›¾ç‰‡åˆ—è¡¨
            if (result && result.images && Array.isArray(result.images)) {
              // å­˜å‚¨å®Œæ•´çš„å›¾ç‰‡å¯¹è±¡ï¼ˆåŒ…å« blockNum ç­‰ä¿¡æ¯ï¼‰åˆ°å“åº”å¼æ•°æ®
              currentChapterImages.value = result.images;
              console.log('[Chapter] å·²è®¾ç½® currentChapterImages, å…±', result.images.length, 'å¼ å›¾ç‰‡');

              // åˆå§‹åŒ–æ—¶æ˜¾ç¤ºåŸå§‹ URLï¼Œåç»­ä¼šå¼‚æ­¥å¤„ç†æ‹¼æ¥ï¼ˆè§£ç ï¼‰
              // å°† readingImages æ”¹ä¸ºå¯¹è±¡æ•°ç»„ï¼ŒåŒ…å« url å’Œ indexï¼Œä»¥ä¾¿åœ¨æ¨¡æ¿ä¸­æ­£ç¡®æ˜¾ç¤ºç´¢å¼•
              readingImages.value = result.images.map((img, idx) => ({
                url: img.url,
                index: idx
              }));

              // å¼‚æ­¥å¤„ç†éœ€è¦æ‹¼æ¥ï¼ˆè§£ç ï¼‰çš„å›¾ç‰‡
              // ä¼˜å…ˆå¤„ç†é¦–å±çš„å°‘é‡å›¾ç‰‡ï¼Œé¿å…ä¸€æ¬¡æ€§å¤„ç†æ•´ç« æ‰€æœ‰å›¾ç‰‡
              const processImages = async () => {
                // å…ˆå¤„ç†ç¬¬ä¸€å¼ å›¾ç‰‡ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
                if (result.images.length > 0) {
                  const firstImage = result.images[0];
                  if (firstImage.blockNum > 0) {
                    try {
                      console.log(`[Image Decode] ä¼˜å…ˆè§£ç ç¬¬ä¸€å¼ å›¾ç‰‡, blockNum: ${firstImage.blockNum}`);
                      const processedUrl = await comicAPI.processImage(firstImage);
                      if (readingImages.value[0]) {
                        readingImages.value[0].url = processedUrl;
                      }
                      console.log(`[Image Decode] ç¬¬ä¸€å¼ å›¾ç‰‡è§£ç å®Œæˆ`);
                    } catch (error) {
                      console.error(`[Image Decode] ç¬¬ä¸€å¼ å›¾ç‰‡è§£ç å¤±è´¥:`, error);
                    }
                  } else {
                    console.log(`[Image Decode] ç¬¬ä¸€å¼ å›¾ç‰‡æ— éœ€è§£ç  (blockNum=0)`);
                  }
                }

                // ç„¶åå¼‚æ­¥å¤„ç†å…¶ä½™å°‘é‡å›¾ç‰‡ï¼Œä¸é˜»å¡UI
                // è¿™é‡Œé™åˆ¶æœ€å¤šåªå¤„ç†å‰ 8 å¼ å›¾ç‰‡ï¼Œé¿å…ä¸€æ¬¡æ€§è§£ç æ•´ç« 
                const MAX_DECODE_IMAGES = 8;
                result.images.forEach(async (image, index) => {
                  // è·³è¿‡ç¬¬ä¸€å¼ ï¼ˆå·²ç»å¤„ç†ï¼‰
                  if (index === 0) return;
                  // è¶…å‡ºé¢„è§£ç æ•°é‡çš„å›¾ç‰‡ä¿æŒåŸå§‹ URLï¼Œç”± n-image çš„ lazy è‡ªå·±å†³å®šä½•æ—¶çœŸæ­£åŠ è½½
                  if (index >= MAX_DECODE_IMAGES) return;

                  if (image.blockNum > 0) {
                    try {
                      console.log(`[Image Decode] å¼€å§‹è§£ç å›¾ç‰‡ ${index + 1}/${result.images.length}, blockNum: ${image.blockNum}`);
                      const processedUrl = await comicAPI.processImage(image);
                      // æ›´æ–°å¯¹åº”ä½ç½®çš„å›¾ç‰‡ URL
                      if (readingImages.value[index]) {
                        readingImages.value[index].url = processedUrl;
                      }
                      console.log(`[Image Decode] å›¾ç‰‡ ${index + 1} è§£ç å®Œæˆ`);
                    } catch (error) {
                      console.error(`[Image Decode] å›¾ç‰‡ ${index + 1} è§£ç å¤±è´¥:`, error);
                      // å¤±è´¥æ—¶ä¿æŒåŸå§‹URLï¼Œç”¨æˆ·ä»èƒ½çœ‹åˆ°å›¾ç‰‡ï¼ˆè™½ç„¶å¯èƒ½æ˜¯ä¹±åºçš„ï¼‰
                    }
                  } else {
                    console.log(`[Image Decode] å›¾ç‰‡ ${index + 1} æ— éœ€è§£ç  (blockNum=0)`);
                  }
                });
              };

              // å¼€å§‹å¤„ç†å›¾ç‰‡
              processImages();
            } else {
              throw new Error('ç« èŠ‚å›¾ç‰‡åˆ—è¡¨ä¸ºç©º');
            }
          } catch (error) {
            if (message) {
              message.error('è·å–ç« èŠ‚å›¾ç‰‡å¤±è´¥: ' + error.message);
            }
            readingImages.value = [];
          } finally {
            detailLoading.value = false;
            // ç­‰å¾… DOM æ›´æ–°åé‡æ–°è®¾ç½®æ»šåŠ¨ç›‘å¬å™¨å¹¶æ›´æ–°å›¾ç‰‡ç´¢å¼•
            nextTick(() => {
              setTimeout(() => {
                // é‡æ–°è®¾ç½®æ»šåŠ¨ç›‘å¬å™¨
                const setupScrollListener = () => {
                  let scrollContainer = document.querySelector('.n-scrollbar-container');
                  if (!scrollContainer) {
                    scrollContainer = document.querySelector('.n-virtual-list');
                  }
                  if (!scrollContainer) {
                    scrollContainer = document.querySelector('.image-virtual-list');
                  }
                  if (!scrollContainer) {
                    const imageWrapper = document.querySelector('.image-preview-wrapper');
                    if (imageWrapper) {
                      scrollContainer = imageWrapper.closest('.n-scrollbar-container') ||
                        imageWrapper.closest('.n-scrollbar') ||
                        imageWrapper.parentElement;
                    }
                  }

                  if (scrollContainer) {
                    // å¦‚æœä¹‹å‰æœ‰ç›‘å¬å™¨ï¼Œå…ˆç§»é™¤
                    if (scrollContainerRef && scrollHandler) {
                      scrollContainerRef.removeEventListener('scroll', scrollHandler);
                    }
                    if (mutationObserver) {
                      mutationObserver.disconnect();
                    }

                    scrollContainerRef = scrollContainer;

                    // ä½¿ç”¨é˜²æŠ–å‡½æ•°ä¼˜åŒ–æ€§èƒ½ï¼Œä½†å“åº”æ›´å¿«
                    let scrollTimer = null;
                    scrollHandler = () => {
                      // ç«‹å³æ›´æ–°ä¸€æ¬¡ï¼ˆç”¨äºå¿«é€Ÿå“åº”ï¼‰
                      updateCurrentImageIndex();
                      // ç„¶åé˜²æŠ–æ›´æ–°ï¼ˆç”¨äºæœ€ç»ˆç¡®è®¤ï¼‰
                      if (scrollTimer) clearTimeout(scrollTimer);
                      scrollTimer = setTimeout(() => {
                        updateCurrentImageIndex();
                      }, 100);
                    };
                    scrollContainer.addEventListener('scroll', scrollHandler, { passive: true });

                    // ç›‘å¬å›¾ç‰‡åŠ è½½ï¼Œæ›´æ–°ç´¢å¼•
                    mutationObserver = new MutationObserver(() => {
                      updateCurrentImageIndex();
                    });
                    mutationObserver.observe(scrollContainer, { childList: true, subtree: true });

                    // è®¾ç½®å›¾ç‰‡è§£ç è§‚å¯Ÿå™¨
                    setupImageDecodeObserver(scrollContainer);

                    // åˆå§‹æ›´æ–°
                    updateCurrentImageIndex();
                  }
                };
                setupScrollListener();
              }, 500);
            });
          }
        };

        // è®¡ç®—æ˜¯å¦æœ‰ä¸Šä¸€ç« 
        const hasPrevChapter = computed(() => {
          if (!chapterList.value || chapterList.value.length === 0 || !currentChapter.value.id) {
            return false;
          }
          const currentIndex = chapterList.value.findIndex(ch => ch.id === currentChapter.value.id);
          return currentIndex > 0;
        });

        // è®¡ç®—æ˜¯å¦æœ‰ä¸‹ä¸€ç« 
        const hasNextChapter = computed(() => {
          if (!chapterList.value || chapterList.value.length === 0 || !currentChapter.value.id) {
            return false;
          }
          const currentIndex = chapterList.value.findIndex(ch => ch.id === currentChapter.value.id);
          return currentIndex >= 0 && currentIndex < chapterList.value.length - 1;
        });

        // è·³è½¬åˆ°ä¸Šä¸€ç« 
        const goToPrevChapter = async () => {
          if (!hasPrevChapter.value) return;

          const currentIndex = chapterList.value.findIndex(ch => ch.id === currentChapter.value.id);
          if (currentIndex > 0) {
            const prevChapter = chapterList.value[currentIndex - 1];
            await selectChapter(prevChapter);
            // æ»šåŠ¨åˆ°é¡¶éƒ¨
            nextTick(() => {
              const scrollContainer = document.querySelector('.n-scrollbar-container');
              if (scrollContainer) {
                scrollContainer.scrollTop = 0;
              }
            });
          }
        };

        // è·³è½¬åˆ°ä¸‹ä¸€ç« 
        const goToNextChapter = async () => {
          if (!hasNextChapter.value) return;

          const currentIndex = chapterList.value.findIndex(ch => ch.id === currentChapter.value.id);
          if (currentIndex >= 0 && currentIndex < chapterList.value.length - 1) {
            const nextChapter = chapterList.value[currentIndex + 1];
            await selectChapter(nextChapter);
            // æ»šåŠ¨åˆ°é¡¶éƒ¨
            nextTick(() => {
              const scrollContainer = document.querySelector('.n-scrollbar-container');
              if (scrollContainer) {
                scrollContainer.scrollTop = 0;
              }
            });
          }
        };

        // æ›´æ–°å½“å‰å›¾ç‰‡ç´¢å¼•ï¼ˆé€šè¿‡ç›‘å¬æ»šåŠ¨ï¼‰
        const updateCurrentImageIndex = () => {
          if (readingImages.value.length === 0) return;

          // å°è¯•å¤šä¸ªå¯èƒ½çš„æ»šåŠ¨å®¹å™¨é€‰æ‹©å™¨
          let scrollContainer = document.querySelector('.n-scrollbar-container');
          if (!scrollContainer) {
            scrollContainer = document.querySelector('.n-virtual-list');
          }
          if (!scrollContainer) {
            scrollContainer = document.querySelector('.image-virtual-list');
          }
          if (!scrollContainer) {
            // å¦‚æœéƒ½æ‰¾ä¸åˆ°ï¼Œå°è¯•æ‰¾åˆ°åŒ…å«å›¾ç‰‡çš„æ»šåŠ¨å®¹å™¨
            const imageWrapper = document.querySelector('.image-preview-wrapper');
            if (imageWrapper) {
              scrollContainer = imageWrapper.closest('.n-scrollbar-container') ||
                imageWrapper.closest('.n-scrollbar') ||
                imageWrapper;
            }
          }

          if (!scrollContainer) return;

          // è·å–æ‰€æœ‰å›¾ç‰‡å…ƒç´ 
          const imageItems = scrollContainer.querySelectorAll('.image-item');
          if (imageItems.length === 0) return;

          // è·å–æ»šåŠ¨å®¹å™¨çš„å¯è§†åŒºåŸŸ
          const containerRect = scrollContainer.getBoundingClientRect();
          const containerTop = containerRect.top;
          const containerCenter = containerTop + scrollContainer.clientHeight / 2;

          // æ‰¾åˆ°æœ€æ¥è¿‘ä¸­å¿ƒä½ç½®çš„å›¾ç‰‡
          let closestIndex = 0;
          let closestDistance = Infinity;
          let maxVisibleRatio = 0;

          imageItems.forEach((item) => {
            // ä» data-index å±æ€§è·å–çœŸå®çš„å›¾ç‰‡ç´¢å¼•
            const realIndex = parseInt(item.getAttribute('data-index') || '-1', 10);
            if (realIndex < 0 || realIndex >= readingImages.value.length) {
              return; // è·³è¿‡æ— æ•ˆç´¢å¼•
            }

            const rect = item.getBoundingClientRect();
            const itemTop = rect.top;
            const itemBottom = rect.bottom;
            const itemHeight = rect.height;

            // è®¡ç®—å›¾ç‰‡åœ¨å¯è§†åŒºåŸŸå†…çš„å¯è§æ¯”ä¾‹
            const visibleTop = Math.max(itemTop, containerRect.top);
            const visibleBottom = Math.min(itemBottom, containerRect.bottom);
            const visibleHeight = Math.max(0, visibleBottom - visibleTop);
            const visibleRatio = visibleHeight / itemHeight;

            // å¦‚æœå›¾ç‰‡åœ¨å¯è§†åŒºåŸŸå†…
            if (itemTop <= containerRect.bottom && itemBottom >= containerRect.top) {
              const itemCenter = (itemTop + itemBottom) / 2;
              const distance = Math.abs(itemCenter - containerCenter);

              // ä¼˜å…ˆé€‰æ‹©å¯è§æ¯”ä¾‹æœ€å¤§çš„ï¼Œå¦‚æœå¯è§æ¯”ä¾‹ç›¸åŒï¼Œé€‰æ‹©è·ç¦»ä¸­å¿ƒæœ€è¿‘çš„
              if (visibleRatio > maxVisibleRatio ||
                (visibleRatio === maxVisibleRatio && distance < closestDistance)) {
                maxVisibleRatio = visibleRatio;
                closestDistance = distance;
                closestIndex = realIndex;
              }
            }
          });

          // å¦‚æœæ‰¾åˆ°äº†æœ‰æ•ˆçš„ç´¢å¼•ï¼Œæ›´æ–°
          if (closestIndex !== currentImageIndex.value) {
            currentImageIndex.value = closestIndex;

            // ä¿å­˜å½“å‰å›¾ç‰‡ç´¢å¼•åˆ° localStorage
            if (currentChapter.value && currentChapter.value.id && currentComic.value && currentComic.value.id) {
              currentViewingChapter.value = {
                comicId: currentComic.value.id,
                chapterId: currentChapter.value.id,
                imageIndex: closestIndex,
                timestamp: Date.now()
              };
            }
          }
        };

        const handleImgError = (e) => {
          // e.target.src = 'fallback_image_url';
        };

        // å¤„ç†å›¾ç‰‡åŠ è½½å®Œæˆï¼šç”¨ç¬¬ä¸€å¼ å®é™…é«˜åº¦å›å¡« estimatedImageHeight
        const handleImageLoad = (e) => {
          const imgEl = e?.target;
          if (!imgEl || imgEl.tagName !== 'IMG') return;

          // æ›´æ–°ä¼°ç®—é«˜åº¦ï¼ˆä»…ç¬¬ä¸€æ¬¡ï¼‰
          if (!hasMeasuredImageHeight.value && imgEl.getBoundingClientRect) {
            const rect = imgEl.getBoundingClientRect();
            if (rect.height && rect.height > 0) {
              estimatedImageHeight.value = Math.round(rect.height);
              hasMeasuredImageHeight.value = true;
            }
          }
        };

        // ==================== å›¾ç‰‡è§£ç  Hooks ====================
        // å›¾ç‰‡è§£ç è§‚å¯Ÿå™¨
        let imageDecodeObserver = null;

        // ä½¿ç”¨å›¾ç‰‡è§£ç  Hook
        const useImageDecode = () => {
          // æŸ¥æ‰¾å›¾ç‰‡å¯¹è±¡
          const findImageObject = (imgSrc) => {
            if (!currentChapterImages.value || !Array.isArray(currentChapterImages.value)) {
              console.log('[Image Decode] currentChapterImages ä¸ºç©ºæˆ–ä¸æ˜¯æ•°ç»„');
              return null;
            }

            // é¦–å…ˆå°è¯•ä» readingImages ä¸­æŸ¥æ‰¾åŒ¹é…çš„ç´¢å¼•
            let matchedIndex = -1;
            if (readingImages.value && Array.isArray(readingImages.value)) {
              matchedIndex = readingImages.value.findIndex(item => {
                if (!item || typeof item !== 'object') return false;
                const proxiedUrl = getProxiedUrl(item.url, true);
                return imgSrc.includes(item.url) || imgSrc.includes(proxiedUrl);
              });
            }

            // å¦‚æœæ‰¾åˆ°äº†åŒ¹é…çš„ç´¢å¼•ï¼Œç›´æ¥è¿”å›å¯¹åº”çš„å›¾ç‰‡å¯¹è±¡
            if (matchedIndex >= 0 && matchedIndex < currentChapterImages.value.length) {
              const imageObj = currentChapterImages.value[matchedIndex];
              console.log('[Image Decode] ä» readingImages æ‰¾åˆ°åŒ¹é…çš„å›¾ç‰‡å¯¹è±¡:', {
                index: matchedIndex,
                filename: imageObj.filename,
                blockNum: imageObj.blockNum,
                url: imageObj.url.substring(0, 50)
              });
              return imageObj;
            }

            // å¦åˆ™ä» currentChapterImages ä¸­æŸ¥æ‰¾
            const imageObj = currentChapterImages.value.find(imgObj => {
              const proxiedUrl = getProxiedUrl(imgObj.url, true);
              const match = imgSrc.includes(imgObj.url) ||
                imgSrc.includes(proxiedUrl) ||
                imgSrc.includes(imgObj.filename) ||
                (imgObj.processedUrl && imgSrc.includes(imgObj.processedUrl));

              if (match) {
                console.log('[Image Decode] æ‰¾åˆ°åŒ¹é…çš„å›¾ç‰‡å¯¹è±¡:', {
                  index: currentChapterImages.value.indexOf(imgObj),
                  filename: imgObj.filename,
                  blockNum: imgObj.blockNum,
                  url: imgObj.url.substring(0, 50)
                });
              }
              return match;
            });

            return imageObj;
          };

          // å¤„ç†å•å¼ å›¾ç‰‡è§£ç 
          const decodeImage = async (img, imageObj, index) => {
            if (!imageObj) {
              console.warn('[Image Decode] å›¾ç‰‡å¯¹è±¡ä¸å­˜åœ¨');
              return;
            }

            console.log(`[Image Decode] å¼€å§‹å¤„ç†å›¾ç‰‡ ${index + 1}`, {
              filename: imageObj.filename,
              blockNum: imageObj.blockNum,
              processedUrl: imageObj.processedUrl,
              isProcessing: imageObj.isProcessing,
              currentSrc: img.src?.substring(0, 50)
            });

            // å¦‚æœå›¾ç‰‡éœ€è¦è§£ç ä¸”å°šæœªå¤„ç†
            if (imageObj.blockNum > 0 && !imageObj.processedUrl && !imageObj.isProcessing) {
              // ä¸è¦åœ¨è¿™é‡Œè®¾ç½® isProcessingï¼Œè®© processImage è‡ªå·±ç®¡ç†
              img.dataset.decoding = 'true';
              console.log(`[Image Decode] å›¾ç‰‡ ${index + 1} å¼€å§‹è§£ç , blockNum: ${imageObj.blockNum}`);

              try {
                // å¼‚æ­¥è§£ç ï¼ˆprocessImage å†…éƒ¨ä¼šç®¡ç† isProcessing çŠ¶æ€ï¼‰
                const processedUrl = await comicAPI.processImage(imageObj);

                // æ£€æŸ¥è¿”å›çš„URLæ˜¯å¦ä¸ºblob URLï¼ˆè§£ç æˆåŠŸï¼‰è¿˜æ˜¯åŸå§‹URLï¼ˆè§£ç å¤±è´¥ï¼‰
                const isBlobUrl = processedUrl && processedUrl.startsWith('blob:');
                console.log(`[Image Decode] å›¾ç‰‡ ${index + 1} è§£ç ${isBlobUrl ? 'æˆåŠŸ' : 'å¤±è´¥ï¼ˆè¿”å›åŸå§‹URLï¼‰'}`, {
                  processedUrl: processedUrl?.substring(0, 50),
                  type: isBlobUrl ? 'blob' : 'url',
                  isBlobUrl: isBlobUrl
                });

                if (processedUrl && isBlobUrl) {
                  // åªæœ‰æˆåŠŸè§£ç ï¼ˆè¿”å›blob URLï¼‰æ—¶æ‰æ›´æ–°å“åº”å¼æ•°æ®åˆ—è¡¨
                  if (index >= 0 && index < readingImages.value.length && readingImages.value[index]) {
                    readingImages.value[index].url = processedUrl;
                    console.log(`[Image Decode] å·²æ›´æ–° readingImages[${index}].url`, processedUrl.substring(0, 50));
                  } else {
                    console.warn(`[Image Decode] ç´¢å¼•è¶…å‡ºèŒƒå›´: ${index}, readingImages.length: ${readingImages.value.length}`);
                  }

                  // processImage å·²ç»åœ¨ finally ä¸­æ¸…é™¤äº† isProcessing
                  img.dataset.decoded = 'true';
                  img.removeAttribute('data-decoding');
                  console.log(`[Image Decode] å›¾ç‰‡ ${index + 1} å¤„ç†å®Œæˆ`);
                } else {
                  // è§£ç å¤±è´¥ï¼Œæ¸…é™¤ processedUrl ä»¥ä¾¿ä¸‹æ¬¡é‡è¯•
                  // processImage å·²ç»åœ¨ finally ä¸­æ¸…é™¤äº† isProcessing
                  console.warn(`[Image Decode] å›¾ç‰‡ ${index + 1} è§£ç å¤±è´¥ï¼Œè¿”å›çš„æ˜¯åŸå§‹URLï¼Œæ¸…é™¤ processedUrl ä»¥ä¾¿é‡è¯•`);
                  imageObj.processedUrl = null;
                  img.removeAttribute('data-decoding');
                }
              } catch (error) {
                console.error(`[Image Decode] å›¾ç‰‡ ${index + 1} è§£ç å¤±è´¥:`, error);
                // æ¸…é™¤ processedUrl ä»¥ä¾¿é‡è¯•
                // processImage å·²ç»åœ¨ finally ä¸­æ¸…é™¤äº† isProcessing
                imageObj.processedUrl = null;
                img.removeAttribute('data-decoding');
              }
            } else if (imageObj.blockNum === 0) {
              // æ— éœ€è§£ç ï¼Œç›´æ¥æ ‡è®°
              img.dataset.decoded = 'true';
              console.log(`[Image Decode] å›¾ç‰‡ ${index + 1} æ— éœ€è§£ç  (blockNum=0)`);
            } else {
              console.log(`[Image Decode] å›¾ç‰‡ ${index + 1} è·³è¿‡å¤„ç†`, {
                blockNum: imageObj.blockNum,
                hasProcessedUrl: !!imageObj.processedUrl,
                isProcessing: imageObj.isProcessing
              });
            }
          };

          // è®¾ç½®å›¾ç‰‡è§£ç ç›‘å¬å™¨ï¼šä½¿ç”¨ MutationObserver ç›‘å¬ img çš„ src å˜åŒ–
          const setupImageDecodeObserver = (container) => {
            if (!container) {
              console.warn('[Image Decode] å®¹å™¨ä¸å­˜åœ¨');
              return;
            }

            console.log('[Image Decode] è®¾ç½®å›¾ç‰‡è§£ç è§‚å¯Ÿå™¨, å®¹å™¨:', container);

            // å¦‚æœå·²å­˜åœ¨è§‚å¯Ÿå™¨ï¼Œå…ˆæ–­å¼€
            if (imageDecodeObserver) {
              imageDecodeObserver.disconnect();
              console.log('[Image Decode] å·²æ–­å¼€æ—§çš„è§‚å¯Ÿå™¨');
            }

            // å°è¯•æ‰¾åˆ°è™šæ‹Ÿåˆ—è¡¨çš„å®é™…å®¹å™¨
            let targetContainer = container;

            // æ–¹æ³•1: é€šè¿‡ imageListRef è·å–è™šæ‹Ÿåˆ—è¡¨å®¹å™¨
            if (imageListRef.value) {
              let virtualListEl = null;
              if (imageListRef.value.$el) {
                virtualListEl = imageListRef.value.$el;
              } else if (imageListRef.value.el) {
                virtualListEl = imageListRef.value.el;
              } else if (imageListRef.value instanceof HTMLElement) {
                virtualListEl = imageListRef.value;
              }

              if (virtualListEl) {
                // æŸ¥æ‰¾è™šæ‹Ÿåˆ—è¡¨çš„å®é™…æ¸²æŸ“å®¹å™¨ï¼ˆé€šå¸¸æ˜¯å†…éƒ¨çš„ä¸€ä¸ª divï¼‰
                const virtualListContainer = virtualListEl.querySelector('.n-virtual-list') ||
                  virtualListEl.querySelector('.image-virtual-list') ||
                  virtualListEl;
                if (virtualListContainer) {
                  targetContainer = virtualListContainer;
                  console.log('[Image Decode] ä½¿ç”¨è™šæ‹Ÿåˆ—è¡¨å®¹å™¨:', targetContainer);
                }
              }
            }

            // æ–¹æ³•2: é€šè¿‡é€‰æ‹©å™¨æŸ¥æ‰¾è™šæ‹Ÿåˆ—è¡¨å®¹å™¨
            if (targetContainer === container) {
              const virtualListEl = document.querySelector('.image-virtual-list') ||
                document.querySelector('#image-scroll-container') ||
                document.querySelector('.n-virtual-list');
              if (virtualListEl) {
                targetContainer = virtualListEl;
                console.log('[Image Decode] é€šè¿‡é€‰æ‹©å™¨æ‰¾åˆ°è™šæ‹Ÿåˆ—è¡¨å®¹å™¨:', targetContainer);
              }
            }

            // ä½¿ç”¨æ‰¾åˆ°çš„å®¹å™¨
            container = targetContainer;

            // é€’å½’æŸ¥æ‰¾æ‰€æœ‰ img å…ƒç´ 
            const findAllImages = (node) => {
              const images = [];
              if (node.nodeType === 1) { // Element node
                if (node.tagName === 'IMG') {
                  images.push(node);
                } else {
                  // æŸ¥æ‰¾å­å…ƒç´ ä¸­çš„æ‰€æœ‰ imgï¼ˆåŒ…æ‹¬æ·±å±‚åµŒå¥—ï¼‰
                  const childImages = node.querySelectorAll('img');
                  images.push(...Array.from(childImages));
                }
              }
              return images;
            };

            // å¤„ç†å•ä¸ªå›¾ç‰‡å…ƒç´ 
            const processImageElement = (img) => {
              if (!img || img.tagName !== 'IMG') return;

              // æ£€æŸ¥æ˜¯å¦å·²ç»å¤„ç†è¿‡
              if (img.dataset.decoded === 'true') {
                console.log('[Image Decode] å›¾ç‰‡å·²å¤„ç†è¿‡ï¼Œè·³è¿‡');
                return;
              }

              // è·å–å½“å‰ src
              const currentSrc = img.src || img.getAttribute('src');

              // å¦‚æœå›¾ç‰‡è¿˜æ²¡æœ‰ srcï¼Œç­‰å¾… src è®¾ç½®æˆ– load äº‹ä»¶
              if (!currentSrc) {
                console.log('[Image Decode] å›¾ç‰‡ src ä¸ºç©ºï¼Œç­‰å¾…è®¾ç½®');
                // ä½¿ç”¨ MutationObserver ç›‘å¬è¿™ä¸ªå…ƒç´ çš„ src å±æ€§
                const srcObserver = new MutationObserver((mutations) => {
                  mutations.forEach((mutation) => {
                    if (mutation.attributeName === 'src') {
                      srcObserver.disconnect();
                      const newSrc = img.src || img.getAttribute('src');
                      if (newSrc) {
                        console.log('[Image Decode] å›¾ç‰‡ src å·²è®¾ç½®ï¼Œé‡æ–°å¤„ç†');
                        processImageElement(img);
                      }
                    }
                  });
                });
                srcObserver.observe(img, { attributes: true, attributeFilter: ['src'] });
                // 3ç§’åè‡ªåŠ¨æ–­å¼€ï¼Œé¿å…å†…å­˜æ³„æ¼
                setTimeout(() => srcObserver.disconnect(), 3000);
                return;
              }

              console.log('[Image Decode] å¤„ç†å›¾ç‰‡å…ƒç´ ', {
                src: currentSrc.substring(0, 50),
                complete: img.complete,
                naturalWidth: img.naturalWidth,
                naturalHeight: img.naturalHeight
              });

              // æŸ¥æ‰¾å¯¹åº”çš„å›¾ç‰‡å¯¹è±¡
              const imageObj = findImageObject(currentSrc);
              if (!imageObj) {
                console.warn('[Image Decode] æœªæ‰¾åˆ°åŒ¹é…çš„å›¾ç‰‡å¯¹è±¡', {
                  src: currentSrc.substring(0, 50)
                });
                return;
              }

              // æ‰¾åˆ°ç´¢å¼•
              const index = currentChapterImages.value.indexOf(imageObj);
              if (index === -1) {
                console.warn('[Image Decode] æ— æ³•æ‰¾åˆ°å›¾ç‰‡ç´¢å¼•');
                return;
              }

              // å¦‚æœå›¾ç‰‡å·²ç»åŠ è½½å®Œæˆï¼Œç«‹å³å¤„ç†
              if (img.complete && img.naturalWidth > 0) {
                console.log('[Image Decode] å›¾ç‰‡å·²åŠ è½½å®Œæˆï¼Œç«‹å³å¤„ç†');
                decodeImage(img, imageObj, index);
              } else {
                // ç­‰å¾…å›¾ç‰‡åŠ è½½å®Œæˆ
                console.log('[Image Decode] ç­‰å¾…å›¾ç‰‡åŠ è½½å®Œæˆ');
                const onLoad = () => {
                  img.removeEventListener('load', onLoad);
                  console.log('[Image Decode] å›¾ç‰‡åŠ è½½å®Œæˆï¼Œå¼€å§‹å¤„ç†');
                  decodeImage(img, imageObj, index);
                };
                img.addEventListener('load', onLoad, { once: true });
                // å¦‚æœå›¾ç‰‡åŠ è½½å¤±è´¥ï¼Œä¹Ÿå°è¯•å¤„ç†ï¼ˆå¯èƒ½å›¾ç‰‡å·²ç»ç¼“å­˜ï¼‰
                img.addEventListener('error', () => {
                  console.log('[Image Decode] å›¾ç‰‡åŠ è½½å¤±è´¥ï¼Œä½†ä»å°è¯•å¤„ç†');
                  decodeImage(img, imageObj, index);
                }, { once: true });
              }
            };

            // åˆ›å»º MutationObserver ç›‘å¬ img å…ƒç´ çš„æ·»åŠ å’Œå±æ€§å˜åŒ–
            imageDecodeObserver = new MutationObserver((mutations) => {
              console.log('[Image Decode] MutationObserver è§¦å‘, mutations æ•°é‡:', mutations.length);

              mutations.forEach((mutation) => {
                console.log('[Image Decode] Mutation ç±»å‹:', mutation.type, {
                  target: mutation.target,
                  addedNodes: mutation.addedNodes.length,
                  removedNodes: mutation.removedNodes.length,
                  attributeName: mutation.attributeName
                });
                if (mutation.type === 'attributes' && mutation.attributeName === 'src') {
                  // src å±æ€§å˜åŒ–
                  const img = mutation.target;
                  console.log('[Image Decode] æ£€æµ‹åˆ° src å±æ€§å˜åŒ–', {
                    tagName: img.tagName,
                    src: (img.src || img.getAttribute('src'))?.substring(0, 50)
                  });
                  processImageElement(img);
                } else if (mutation.type === 'childList') {
                  // æ–°å¢æˆ–åˆ é™¤èŠ‚ç‚¹
                  console.log('[Image Decode] æ£€æµ‹åˆ° DOM å˜åŒ– (childList)', {
                    addedNodes: mutation.addedNodes.length,
                    removedNodes: mutation.removedNodes.length
                  });

                  // å¤„ç†æ–°å¢çš„èŠ‚ç‚¹ï¼Œé€’å½’æŸ¥æ‰¾æ‰€æœ‰ img å…ƒç´ 
                  mutation.addedNodes.forEach((node) => {
                    const images = findAllImages(node);
                    console.log(`[Image Decode] åœ¨æ–°å¢èŠ‚ç‚¹ä¸­æ‰¾åˆ° ${images.length} å¼ å›¾ç‰‡`);
                    images.forEach((img) => {
                      processImageElement(img);
                    });
                  });
                }
              });
            });

            // è§‚å¯Ÿå®¹å™¨å†…æ‰€æœ‰å˜åŒ–ï¼ˆé‡ç‚¹æ˜¯ childListï¼Œç›‘å¬æ–°å¢å…ƒç´ ï¼‰
            imageDecodeObserver.observe(container, {
              childList: true,  // ç›‘å¬å­èŠ‚ç‚¹çš„æ·»åŠ å’Œåˆ é™¤ï¼ˆé‡è¦ï¼ï¼‰
              subtree: true,    // ç›‘å¬æ‰€æœ‰åä»£èŠ‚ç‚¹
              attributes: true, // ç›‘å¬å±æ€§å˜åŒ–
              attributeFilter: ['src'] // åªç›‘å¬ src å±æ€§
            });

            console.log('[Image Decode] è§‚å¯Ÿå™¨å·²å¯åŠ¨ï¼Œç›‘å¬å®¹å™¨:', container, {
              childList: true,
              subtree: true,
              attributes: true
            });

            console.log('[Image Decode] è§‚å¯Ÿå™¨å·²å¯åŠ¨');

            // å¤„ç†å·²å­˜åœ¨çš„å›¾ç‰‡
            const existingImages = container.querySelectorAll('.image-item img');
            console.log(`[Image Decode] å¤„ç†å·²å­˜åœ¨çš„å›¾ç‰‡ï¼Œå…± ${existingImages.length} å¼ `);

            existingImages.forEach((img) => {
              processImageElement(img);
            });

            // æ·»åŠ å®šæœŸæ£€æŸ¥æœºåˆ¶ï¼ˆä½œä¸º MutationObserver çš„å¤‡ç”¨æ–¹æ¡ˆï¼‰
            // è™šæ‹Ÿåˆ—è¡¨å¯èƒ½ä¸ä¼šè§¦å‘ MutationObserverï¼Œæ‰€ä»¥å®šæœŸæ£€æŸ¥æ–°å›¾ç‰‡
            let checkInterval = null;
            const checkNewImages = () => {
              const allImages = container.querySelectorAll('.image-item img');
              let newCount = 0;
              allImages.forEach((img) => {
                if (!img.dataset.decoded && !img.dataset.checking) {
                  img.dataset.checking = 'true';
                  newCount++;
                  processImageElement(img);
                }
              });
              if (newCount > 0) {
                console.log(`[Image Decode] å®šæœŸæ£€æŸ¥å‘ç° ${newCount} å¼ æ–°å›¾ç‰‡`);
              }
            };

            // æ¯ 500ms æ£€æŸ¥ä¸€æ¬¡æ–°å›¾ç‰‡
            checkInterval = setInterval(checkNewImages, 500);

            // ä¿å­˜ interval IDï¼Œä»¥ä¾¿æ¸…ç†
            if (!container._decodeCheckInterval) {
              container._decodeCheckInterval = checkInterval;
            }

            console.log('[Image Decode] å·²å¯åŠ¨å®šæœŸæ£€æŸ¥æœºåˆ¶ï¼ˆæ¯ 500msï¼‰');
          };

          // æ¸…ç†è§‚å¯Ÿå™¨
          const cleanupImageDecodeObserver = () => {
            if (imageDecodeObserver) {
              imageDecodeObserver.disconnect();
              imageDecodeObserver = null;
              console.log('[Image Decode] å·²æ¸…ç†è§‚å¯Ÿå™¨');
            }

            // æ¸…ç†å®šæœŸæ£€æŸ¥
            const containers = document.querySelectorAll('.image-virtual-list, #image-scroll-container, .n-virtual-list');
            containers.forEach(container => {
              if (container._decodeCheckInterval) {
                clearInterval(container._decodeCheckInterval);
                container._decodeCheckInterval = null;
                console.log('[Image Decode] å·²æ¸…ç†å®šæœŸæ£€æŸ¥');
              }
            });
          };

          return {
            setupImageDecodeObserver,
            cleanupImageDecodeObserver
          };
        };

        // ä½¿ç”¨å›¾ç‰‡è§£ç  Hook
        const { setupImageDecodeObserver, cleanupImageDecodeObserver } = useImageDecode();

        // å¤„ç†å›¾ç‰‡åŠ è½½é”™è¯¯
        const handleImageError = (e) => {
          // é”™è¯¯å¤„ç†å·²åœ¨æ¨¡æ¿ä¸­å®Œæˆ
        };

        const saveSettings = () => {
          // æ›´æ–° API é…ç½®
          if (comicAPI) {
            comicAPI.updateSettings(settings.value);
          }
          showSettings.value = false;
          if (message) {
            message.success('è®¾ç½®å·²ä¿å­˜');
          }
          // å¦‚æœæœ‰æœç´¢è¯ï¼Œé‡æ–°æœç´¢
          if (searchQuery.value) {
            currentPage.value = 1;
            handleSearch(1, false);
          }
        };

        const resetSettings = () => {
          settings.value = {
            proxyUrl: '',
            apiDomain: 'www.cdnblackmyth.club',
            imageDomain: 'cdn-msp2.jmapiproxy2.cc',
            appTokenSecret: '18comicAPP',
            appTokenSecret2: '18comicAPPContent',
            appDataSecret: '185Hcomic3PAPP7R',
            appVersion: '1.7.5'
          };
          if (message) {
            message.info('å·²é‡ç½®ä¸ºé»˜è®¤è®¾ç½®');
          }
        };

        // æ¸…é™¤ç¼“å­˜
        const clearCache = (type = null) => {
          cacheUtils.clear(type);
          if (message) {
            if (type) {
              message.success(`å·²æ¸…é™¤${type === 'details' ? 'è¯¦æƒ…' : 'å›¾ç‰‡'}ç¼“å­˜`);
            } else {
              message.success('å·²æ¸…é™¤æ‰€æœ‰ç¼“å­˜');
            }
          }
        };

        // è·å–ç¼“å­˜æ•°é‡
        const getCacheCount = (type) => {
          const cache = cacheStore.value[type];
          if (!cache) return 0;
          return Object.keys(cache).length;
        };

        // ResizeObserver å®ä¾‹
        let resizeObserver = null;

        // æ»šåŠ¨ç›‘å¬å™¨ç›¸å…³
        let scrollContainerRef = null;
        let scrollHandler = null;
        let mutationObserver = null;
        let intersectionObserver = null;

        // åˆå§‹åŒ–
        onMounted(() => {
          // æ¸…é™¤è¿‡æœŸç¼“å­˜
          cacheUtils.clearExpired();

          // useStorage ä¼šè‡ªåŠ¨åŠ è½½ï¼Œæ£€æŸ¥æ˜¯å¦æœ‰ä¿å­˜çš„æ•°æ®
          const saved = savedSearchResults.value;
          if (saved && saved.comicList && saved.comicList.length > 0) {
            // åŒæ­¥ä¿å­˜çš„æ•°æ®åˆ°å½“å‰çŠ¶æ€
            comicList.value = saved.comicList;
            searchQuery.value = saved.searchQuery || '';
            currentPage.value = saved.currentPage || 1;
            totalItems.value = saved.totalItems || 0;
            totalPages.value = saved.totalPages || 1;
            hasMorePages.value = saved.hasMorePages !== undefined ? saved.hasMorePages : true;

            // æ£€æŸ¥æ˜¯å¦æœ‰ä¿å­˜çš„å½“å‰æŸ¥çœ‹æ¼«ç”»ï¼Œå¦‚æœæœ‰åˆ™è‡ªåŠ¨æ¢å¤
            const viewingComic = currentViewingComic.value;
            const viewingChapter = currentViewingChapter.value;

            if (viewingComic && viewingComic.id) {
              // å»¶è¿Ÿæ¢å¤ï¼Œç¡®ä¿åˆ—è¡¨å·²åŠ è½½
              setTimeout(async () => {
                let restoredComic = null;

                // åœ¨æ¼«ç”»åˆ—è¡¨ä¸­æŸ¥æ‰¾å¯¹åº”çš„æ¼«ç”»
                const foundComic = comicList.value.find(c => c.id === viewingComic.id);
                if (foundComic) {
                  console.log('[Restore] æ¢å¤ä¹‹å‰æŸ¥çœ‹çš„æ¼«ç”»:', viewingComic.id);
                  restoredComic = foundComic;
                  await viewDetail(foundComic);
                } else {
                  // å¦‚æœåˆ—è¡¨ä¸­æ²¡æœ‰ï¼Œå°è¯•ä»ç¼“å­˜æ¢å¤åŸºæœ¬ä¿¡æ¯
                  const cachedDetail = cacheUtils.get(viewingComic.id, 'details');
                  if (cachedDetail && typeof cachedDetail === 'object') {
                    console.log('[Restore] ä»ç¼“å­˜æ¢å¤æ¼«ç”»è¯¦æƒ…:', viewingComic.id);
                    // æ„é€ ä¸€ä¸ªåŸºæœ¬çš„æ¼«ç”»å¯¹è±¡
                    const albumId = cachedDetail.id || viewingComic.id;
                    const rawCover = cachedDetail.thumb || cachedDetail.cover || cachedDetail.thumb_url || '';
                    const basicComic = {
                      id: viewingComic.id,
                      title: cachedDetail.title || cachedDetail.name || 'æœªçŸ¥æ ‡é¢˜',
                      author: cachedDetail.author || cachedDetail.author_name || 'æœªçŸ¥ä½œè€…',
                      cover: processCoverUrl(rawCover, albumId),
                      description: cachedDetail.description || cachedDetail.intro || '',
                      tags: cachedDetail.tags || cachedDetail.tag_list || []
                    };
                    restoredComic = basicComic;
                    await viewDetail(basicComic);
                  } else {
                    console.log('[Restore] æ— æ³•æ¢å¤æ¼«ç”»ï¼Œç¼“å­˜ä¸­ä¸å­˜åœ¨:', viewingComic.id);
                  }
                }

                // å¦‚æœæ¢å¤äº†æ¼«ç”»ï¼Œå¹¶ä¸”æœ‰ä¿å­˜çš„ç« èŠ‚ä¿¡æ¯ï¼Œåˆ™æ¢å¤ç« èŠ‚
                if (restoredComic && viewingChapter && viewingChapter.chapterId && viewingChapter.comicId === viewingComic.id) {
                  // ç­‰å¾…ç« èŠ‚åˆ—è¡¨åŠ è½½å®Œæˆ
                  setTimeout(() => {
                    const foundChapter = chapterList.value.find(ch => ch.id === viewingChapter.chapterId);
                    if (foundChapter) {
                      console.log('[Restore] æ¢å¤ä¹‹å‰æŸ¥çœ‹çš„ç« èŠ‚:', viewingChapter.chapterId, 'å›¾ç‰‡ç´¢å¼•:', viewingChapter.imageIndex);
                      selectChapter(foundChapter).then(() => {
                        // æ¢å¤å›¾ç‰‡ç´¢å¼•
                        if (viewingChapter.imageIndex > 0) {
                          currentImageIndex.value = viewingChapter.imageIndex;
                          // æ»šåŠ¨åˆ°å¯¹åº”ä½ç½®
                          nextTick(() => {
                            setTimeout(() => {
                              const scrollContainer = document.querySelector('.n-scrollbar-container');
                              if (scrollContainer && readingImages.value.length > viewingChapter.imageIndex) {
                                // è®¡ç®—ç›®æ ‡å›¾ç‰‡çš„ä½ç½®å¹¶æ»šåŠ¨
                                const imageItems = scrollContainer.querySelectorAll('.image-item');
                                if (imageItems[viewingChapter.imageIndex]) {
                                  imageItems[viewingChapter.imageIndex].scrollIntoView({ behavior: 'smooth', block: 'center' });
                                }
                              }
                            }, 1000);
                          });
                        }
                      });
                    } else {
                      console.log('[Restore] æ— æ³•æ¢å¤ç« èŠ‚ï¼Œç« èŠ‚åˆ—è¡¨ä¸­ä¸å­˜åœ¨:', viewingChapter.chapterId);
                    }
                  }, 500);
                }
              }, 800); // å¢åŠ å»¶è¿Ÿï¼Œç¡®ä¿åˆ—è¡¨å·²å®Œå…¨åŠ è½½
            }
          }

          // å»¶è¿Ÿ 500msï¼Œå¦‚æœæ²¡æœ‰æ•°æ®ï¼Œåˆ™åŠ è½½æ¨¡æ‹Ÿæ•°æ®
          setTimeout(() => {
            if (comicList.value.length === 0) {
              loadMockData();
            }
          }, 500);

          nextTick(() => {
            updateLeftPanelWidth();
            window.addEventListener('resize', handleResize);
            // æ·»åŠ é”®ç›˜äº‹ä»¶ç›‘å¬
            window.addEventListener('keydown', handleKeyDown);
            // ä½¿ç”¨ ResizeObserver ç›‘å¬å·¦ä¾§é¢æ¿å®½åº¦å˜åŒ–
            if (leftPanelRef.value) {
              let panelEl = null;
              if (leftPanelRef.value instanceof HTMLElement) {
                panelEl = leftPanelRef.value;
              } else if (leftPanelRef.value && typeof leftPanelRef.value === 'object' && '$el' in leftPanelRef.value) {
                panelEl = leftPanelRef.value.$el;
              } else if (leftPanelRef.value && typeof leftPanelRef.value === 'object' && 'el' in leftPanelRef.value) {
                panelEl = leftPanelRef.value.el;
              }

              if (panelEl && panelEl instanceof Element) {
                resizeObserver = new ResizeObserver(() => {
                  updateLeftPanelWidth();
                });
                resizeObserver.observe(panelEl);
              }
            }

            // æ·»åŠ æ»šåŠ¨ç›‘å¬å™¨ï¼Œç”¨äºæ›´æ–°å½“å‰å›¾ç‰‡ç´¢å¼•
            const setupScrollListener = () => {
              // å°è¯•å¤šä¸ªå¯èƒ½çš„æ»šåŠ¨å®¹å™¨
              let scrollContainer = document.querySelector('.n-scrollbar-container');
              if (!scrollContainer) {
                scrollContainer = document.querySelector('.n-virtual-list');
              }
              if (!scrollContainer) {
                scrollContainer = document.querySelector('.image-virtual-list');
              }
              if (!scrollContainer) {
                const imageWrapper = document.querySelector('.image-preview-wrapper');
                if (imageWrapper) {
                  scrollContainer = imageWrapper.closest('.n-scrollbar-container') ||
                    imageWrapper.closest('.n-scrollbar') ||
                    imageWrapper.parentElement;
                }
              }

              if (scrollContainer) {
                // å¦‚æœä¹‹å‰æœ‰ç›‘å¬å™¨ï¼Œå…ˆç§»é™¤
                if (scrollContainerRef && scrollHandler) {
                  scrollContainerRef.removeEventListener('scroll', scrollHandler);
                }
                if (mutationObserver) {
                  mutationObserver.disconnect();
                }

                scrollContainerRef = scrollContainer;

                // ä½¿ç”¨é˜²æŠ–å‡½æ•°ä¼˜åŒ–æ€§èƒ½ï¼Œä½†å“åº”æ›´å¿«
                let scrollTimer = null;
                scrollHandler = () => {
                  // ç«‹å³æ›´æ–°ä¸€æ¬¡ï¼ˆç”¨äºå¿«é€Ÿå“åº”ï¼‰
                  updateCurrentImageIndex();
                  // ç„¶åé˜²æŠ–æ›´æ–°ï¼ˆç”¨äºæœ€ç»ˆç¡®è®¤ï¼‰
                  if (scrollTimer) clearTimeout(scrollTimer);
                  scrollTimer = setTimeout(() => {
                    updateCurrentImageIndex();
                  }, 100);
                };
                scrollContainer.addEventListener('scroll', scrollHandler, { passive: true });

                // ç›‘å¬å›¾ç‰‡åŠ è½½ï¼Œæ›´æ–°ç´¢å¼•
                mutationObserver = new MutationObserver(() => {
                  updateCurrentImageIndex();
                });
                mutationObserver.observe(scrollContainer, { childList: true, subtree: true });

                // è®¾ç½®å›¾ç‰‡è§£ç è§‚å¯Ÿå™¨
                setupImageDecodeObserver(scrollContainer);

                // åˆå§‹æ›´æ–°
                updateCurrentImageIndex();
              } else {
                // å¦‚æœè¿˜æ²¡å‡†å¤‡å¥½ï¼Œå»¶è¿Ÿé‡è¯•
                setTimeout(setupScrollListener, 300);
              }
            };

            // å»¶è¿Ÿè®¾ç½®æ»šåŠ¨ç›‘å¬å™¨ï¼Œç¡®ä¿ DOM å·²æ¸²æŸ“
            setTimeout(setupScrollListener, 500);

            // ç›‘å¬ tab åˆ‡æ¢ï¼Œé‡æ–°è®¾ç½®æ»šåŠ¨ç›‘å¬å™¨
            watch(rightTab, (newTab) => {
              if (newTab === 'images') {
                setTimeout(setupScrollListener, 300);
              }
            });
          });
        });

        // æ¸…ç†
        onUnmounted(() => {
          window.removeEventListener('resize', handleResize);
          window.removeEventListener('keydown', handleKeyDown);
          if (resizeObserver) {
            resizeObserver.disconnect();
          }
          // æ¸…ç†æ»šåŠ¨ç›‘å¬å™¨
          if (scrollContainerRef && scrollHandler) {
            scrollContainerRef.removeEventListener('scroll', scrollHandler);
          }
          if (mutationObserver) {
            mutationObserver.disconnect();
          }
          if (intersectionObserver) {
            intersectionObserver.disconnect();
          }
          // æ¸…ç†å›¾ç‰‡è§£ç è§‚å¯Ÿå™¨
          cleanupImageDecodeObserver();
        });



        // æš—è‰²ä¸»é¢˜é…ç½®
        const darkTheme = naive.darkTheme;

        return {
          darkTheme,
          loading,
          detailLoading,
          searchQuery,
          showSettings,
          settings,
          comicList,
          currentComic,
          chapterList,
          currentChapter,
          readingImages,
          currentImageIndex,
          // ç« èŠ‚å¯¼èˆª
          hasPrevChapter,
          hasNextChapter,
          // åˆ†é¡µç›¸å…³
          currentPage,
          hasMorePages,
          totalPages,
          totalItems,
          pageSize,
          autoLoadNextPage,
          leftColumnCount,
          leftPanelRef,
          imageListRef,
          currentImageIndexProxy,
          handleImageListScroll,
          // Tab
          rightTab,
          // Split
          splitSize,
          // å›¾ç‰‡ç¼©æ”¾
          imageScale,
          // è™šæ‹Ÿåˆ—è¡¨
          estimatedImageHeight,
          handleImageLoad,
          handleImageError,
          // n-select ä¸‹æ‹‰é€‰é¡¹
          proxyUrlOptions,
          apiDomainOptions,
          imageDomainOptions,
          tokenSecretOptions,
          tokenSecret2Options,
          dataSecretOptions,
          appVersionOptions,
          // Methods
          goHome,
          handleSearch,
          loadNextPage,
          handleLoad,
          handlePageChange,
          handlePageSizeChange,
          viewDetail,
          selectChapter,
          goToPrevChapter,
          goToNextChapter,
          updateCurrentImageIndex,
          toggleRightPanel,
          toggleLeftPanel,
          getProxiedUrl,
          processCoverUrl,
          handleImgError,
          saveSettings,
          resetSettings,
          clearCache,
          getCacheCount
        };
      }
    });

    app.use(naive);

    app.mount('#app');
  </script>

</body>

</html>
</body>

</html>